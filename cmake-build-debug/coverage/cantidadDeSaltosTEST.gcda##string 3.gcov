        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.3.sdk/usr/include/c++/v1/string
        -:    0:Graph:/Users/IAGO/Desktop/TPI/cmake-build-debug/CMakeFiles/tpi.dir/testEnunciado/cantidadDeSaltosTEST.gcno
        -:    0:Data:/Users/IAGO/Desktop/TPI/cmake-build-debug/CMakeFiles/tpi.dir/testEnunciado/cantidadDeSaltosTEST.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===--------------------------- string -----------------------------------===//
        -:    3://
        -:    4:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    5:// See https://llvm.org/LICENSE.txt for license information.
        -:    6:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    7://
        -:    8://===----------------------------------------------------------------------===//
        -:    9:
        -:   10:#ifndef _LIBCPP_STRING
        -:   11:#define _LIBCPP_STRING
        -:   12:
        -:   13:/*
        -:   14:    string synopsis
        -:   15:
        -:   16:namespace std
        -:   17:{
        -:   18:
        -:   19:template <class stateT>
        -:   20:class fpos
        -:   21:{
        -:   22:private:
        -:   23:    stateT st;
        -:   24:public:
        -:   25:    fpos(streamoff = streamoff());
        -:   26:
        -:   27:    operator streamoff() const;
        -:   28:
        -:   29:    stateT state() const;
        -:   30:    void state(stateT);
        -:   31:
        -:   32:    fpos& operator+=(streamoff);
        -:   33:    fpos  operator+ (streamoff) const;
        -:   34:    fpos& operator-=(streamoff);
        -:   35:    fpos  operator- (streamoff) const;
        -:   36:};
        -:   37:
        -:   38:template <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);
        -:   39:
        -:   40:template <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);
        -:   41:template <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);
        -:   42:
        -:   43:template <class charT>
        -:   44:struct char_traits
        -:   45:{
        -:   46:    typedef charT     char_type;
        -:   47:    typedef ...       int_type;
        -:   48:    typedef streamoff off_type;
        -:   49:    typedef streampos pos_type;
        -:   50:    typedef mbstate_t state_type;
        -:   51:
        -:   52:    static void assign(char_type& c1, const char_type& c2) noexcept;
        -:   53:    static constexpr bool eq(char_type c1, char_type c2) noexcept;
        -:   54:    static constexpr bool lt(char_type c1, char_type c2) noexcept;
        -:   55:
        -:   56:    static int              compare(const char_type* s1, const char_type* s2, size_t n);
        -:   57:    static size_t           length(const char_type* s);
        -:   58:    static const char_type* find(const char_type* s, size_t n, const char_type& a);
        -:   59:    static char_type*       move(char_type* s1, const char_type* s2, size_t n);
        -:   60:    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);
        -:   61:    static char_type*       assign(char_type* s, size_t n, char_type a);
        -:   62:
        -:   63:    static constexpr int_type  not_eof(int_type c) noexcept;
        -:   64:    static constexpr char_type to_char_type(int_type c) noexcept;
        -:   65:    static constexpr int_type  to_int_type(char_type c) noexcept;
        -:   66:    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;
        -:   67:    static constexpr int_type  eof() noexcept;
        -:   68:};
        -:   69:
        -:   70:template <> struct char_traits<char>;
        -:   71:template <> struct char_traits<wchar_t>;
        -:   72:template <> struct char_traits<char8_t>;  // C++20
        -:   73:template <> struct char_traits<char16_t>;
        -:   74:template <> struct char_traits<char32_t>;
        -:   75:
        -:   76:template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
        -:   77:class basic_string
        -:   78:{
        -:   79:public:
        -:   80:// types:
        -:   81:    typedef traits traits_type;
        -:   82:    typedef typename traits_type::char_type value_type;
        -:   83:    typedef Allocator allocator_type;
        -:   84:    typedef typename allocator_type::size_type size_type;
        -:   85:    typedef typename allocator_type::difference_type difference_type;
        -:   86:    typedef typename allocator_type::reference reference;
        -:   87:    typedef typename allocator_type::const_reference const_reference;
        -:   88:    typedef typename allocator_type::pointer pointer;
        -:   89:    typedef typename allocator_type::const_pointer const_pointer;
        -:   90:    typedef implementation-defined iterator;
        -:   91:    typedef implementation-defined const_iterator;
        -:   92:    typedef std::reverse_iterator<iterator> reverse_iterator;
        -:   93:    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        -:   94:
        -:   95:    static const size_type npos = -1;
        -:   96:
        -:   97:    basic_string()
        -:   98:        noexcept(is_nothrow_default_constructible<allocator_type>::value);
        -:   99:    explicit basic_string(const allocator_type& a);
        -:  100:    basic_string(const basic_string& str);
        -:  101:    basic_string(basic_string&& str)
        -:  102:        noexcept(is_nothrow_move_constructible<allocator_type>::value);
        -:  103:    basic_string(const basic_string& str, size_type pos,
        -:  104:                 const allocator_type& a = allocator_type());
        -:  105:    basic_string(const basic_string& str, size_type pos, size_type n,
        -:  106:                 const Allocator& a = Allocator());
        -:  107:    template<class T>
        -:  108:        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17
        -:  109:    template <class T>
        -:  110:        explicit basic_string(const T& t, const Allocator& a = Allocator()); // C++17
        -:  111:    basic_string(const value_type* s, const allocator_type& a = allocator_type());
        -:  112:    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());
        -:  113:    basic_string(nullptr_t) = delete; // C++2b
        -:  114:    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());
        -:  115:    template<class InputIterator>
        -:  116:        basic_string(InputIterator begin, InputIterator end,
        -:  117:                     const allocator_type& a = allocator_type());
        -:  118:    basic_string(initializer_list<value_type>, const Allocator& = Allocator());
        -:  119:    basic_string(const basic_string&, const Allocator&);
        -:  120:    basic_string(basic_string&&, const Allocator&);
        -:  121:
        -:  122:    ~basic_string();
        -:  123:
        -:  124:    operator basic_string_view<charT, traits>() const noexcept;
        -:  125:
        -:  126:    basic_string& operator=(const basic_string& str);
        -:  127:    template <class T>
        -:  128:        basic_string& operator=(const T& t); // C++17
        -:  129:    basic_string& operator=(basic_string&& str)
        -:  130:        noexcept(
        -:  131:             allocator_type::propagate_on_container_move_assignment::value ||
        -:  132:             allocator_type::is_always_equal::value ); // C++17
        -:  133:    basic_string& operator=(const value_type* s);
        -:  134:    basic_string& operator=(nullptr_t) = delete; // C++2b
        -:  135:    basic_string& operator=(value_type c);
        -:  136:    basic_string& operator=(initializer_list<value_type>);
        -:  137:
        -:  138:    iterator       begin() noexcept;
        -:  139:    const_iterator begin() const noexcept;
        -:  140:    iterator       end() noexcept;
        -:  141:    const_iterator end() const noexcept;
        -:  142:
        -:  143:    reverse_iterator       rbegin() noexcept;
        -:  144:    const_reverse_iterator rbegin() const noexcept;
        -:  145:    reverse_iterator       rend() noexcept;
        -:  146:    const_reverse_iterator rend() const noexcept;
        -:  147:
        -:  148:    const_iterator         cbegin() const noexcept;
        -:  149:    const_iterator         cend() const noexcept;
        -:  150:    const_reverse_iterator crbegin() const noexcept;
        -:  151:    const_reverse_iterator crend() const noexcept;
        -:  152:
        -:  153:    size_type size() const noexcept;
        -:  154:    size_type length() const noexcept;
        -:  155:    size_type max_size() const noexcept;
        -:  156:    size_type capacity() const noexcept;
        -:  157:
        -:  158:    void resize(size_type n, value_type c);
        -:  159:    void resize(size_type n);
        -:  160:
        -:  161:    void reserve(size_type res_arg);
        -:  162:    void reserve(); // deprecated in C++20
        -:  163:    void shrink_to_fit();
        -:  164:    void clear() noexcept;
        -:  165:    bool empty() const noexcept;
        -:  166:
        -:  167:    const_reference operator[](size_type pos) const;
        -:  168:    reference       operator[](size_type pos);
        -:  169:
        -:  170:    const_reference at(size_type n) const;
        -:  171:    reference       at(size_type n);
        -:  172:
        -:  173:    basic_string& operator+=(const basic_string& str);
        -:  174:    template <class T>
        -:  175:        basic_string& operator+=(const T& t);              // C++17
        -:  176:    basic_string& operator+=(const value_type* s);
        -:  177:    basic_string& operator+=(value_type c);
        -:  178:    basic_string& operator+=(initializer_list<value_type>);
        -:  179:
        -:  180:    basic_string& append(const basic_string& str);
        -:  181:    template <class T>
        -:  182:        basic_string& append(const T& t);                 // C++17
        -:  183:    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14
        -:  184:    template <class T>
        -:  185:        basic_string& append(const T& t, size_type pos, size_type n=npos); // C++17
        -:  186:    basic_string& append(const value_type* s, size_type n);
        -:  187:    basic_string& append(const value_type* s);
        -:  188:    basic_string& append(size_type n, value_type c);
        -:  189:    template<class InputIterator>
        -:  190:        basic_string& append(InputIterator first, InputIterator last);
        -:  191:    basic_string& append(initializer_list<value_type>);
        -:  192:
        -:  193:    void push_back(value_type c);
        -:  194:    void pop_back();
        -:  195:    reference       front();
        -:  196:    const_reference front() const;
        -:  197:    reference       back();
        -:  198:    const_reference back() const;
        -:  199:
        -:  200:    basic_string& assign(const basic_string& str);
        -:  201:    template <class T>
        -:  202:        basic_string& assign(const T& t);  // C++17
        -:  203:    basic_string& assign(basic_string&& str);
        -:  204:    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14
        -:  205:    template <class T>
        -:  206:        basic_string& assign(const T& t, size_type pos, size_type n=npos); // C++17
        -:  207:    basic_string& assign(const value_type* s, size_type n);
        -:  208:    basic_string& assign(const value_type* s);
        -:  209:    basic_string& assign(size_type n, value_type c);
        -:  210:    template<class InputIterator>
        -:  211:        basic_string& assign(InputIterator first, InputIterator last);
        -:  212:    basic_string& assign(initializer_list<value_type>);
        -:  213:
        -:  214:    basic_string& insert(size_type pos1, const basic_string& str);
        -:  215:    template <class T>
        -:  216:        basic_string& insert(size_type pos1, const T& t);
        -:  217:    basic_string& insert(size_type pos1, const basic_string& str,
        -:  218:                         size_type pos2, size_type n);
        -:  219:    template <class T>
        -:  220:        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n); // C++17
        -:  221:    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14
        -:  222:    basic_string& insert(size_type pos, const value_type* s);
        -:  223:    basic_string& insert(size_type pos, size_type n, value_type c);
        -:  224:    iterator      insert(const_iterator p, value_type c);
        -:  225:    iterator      insert(const_iterator p, size_type n, value_type c);
        -:  226:    template<class InputIterator>
        -:  227:        iterator insert(const_iterator p, InputIterator first, InputIterator last);
        -:  228:    iterator      insert(const_iterator p, initializer_list<value_type>);
        -:  229:
        -:  230:    basic_string& erase(size_type pos = 0, size_type n = npos);
        -:  231:    iterator      erase(const_iterator position);
        -:  232:    iterator      erase(const_iterator first, const_iterator last);
        -:  233:
        -:  234:    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);
        -:  235:    template <class T>
        -:  236:    basic_string& replace(size_type pos1, size_type n1, const T& t);  // C++17
        -:  237:    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,
        -:  238:                          size_type pos2, size_type n2=npos); // C++14
        -:  239:    template <class T>
        -:  240:        basic_string& replace(size_type pos1, size_type n1, const T& t,
        -:  241:                              size_type pos2, size_type n); // C++17
        -:  242:    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);
        -:  243:    basic_string& replace(size_type pos, size_type n1, const value_type* s);
        -:  244:    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);
        -:  245:    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);
        -:  246:    template <class T>
        -:  247:        basic_string& replace(const_iterator i1, const_iterator i2, const T& t);  // C++17
        -:  248:    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);
        -:  249:    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);
        -:  250:    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);
        -:  251:    template<class InputIterator>
        -:  252:        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);
        -:  253:    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);
        -:  254:
        -:  255:    size_type copy(value_type* s, size_type n, size_type pos = 0) const;
        -:  256:    basic_string substr(size_type pos = 0, size_type n = npos) const;
        -:  257:
        -:  258:    void swap(basic_string& str)
        -:  259:        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||
        -:  260:                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17
        -:  261:
        -:  262:    const value_type* c_str() const noexcept;
        -:  263:    const value_type* data() const noexcept;
        -:  264:          value_type* data()       noexcept;   // C++17
        -:  265:
        -:  266:    allocator_type get_allocator() const noexcept;
        -:  267:
        -:  268:    size_type find(const basic_string& str, size_type pos = 0) const noexcept;
        -:  269:    template <class T>
        -:  270:        size_type find(const T& t, size_type pos = 0) const noexcept; // C++17, noexcept as an extension
        -:  271:    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;
        -:  272:    size_type find(const value_type* s, size_type pos = 0) const noexcept;
        -:  273:    size_type find(value_type c, size_type pos = 0) const noexcept;
        -:  274:
        -:  275:    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;
        -:  276:    template <class T>
        -:  277:        size_type rfind(const T& t, size_type pos = npos) const noexcept; // C++17, noexcept as an extension
        -:  278:    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;
        -:  279:    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;
        -:  280:    size_type rfind(value_type c, size_type pos = npos) const noexcept;
        -:  281:
        -:  282:    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;
        -:  283:    template <class T>
        -:  284:        size_type find_first_of(const T& t, size_type pos = 0) const noexcept; // C++17, noexcept as an extension
        -:  285:    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;
        -:  286:    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;
        -:  287:    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;
        -:  288:
        -:  289:    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;
        -:  290:    template <class T>
        -:  291:        size_type find_last_of(const T& t, size_type pos = npos) const noexcept noexcept; // C++17, noexcept as an extension
        -:  292:    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;
        -:  293:    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;
        -:  294:    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;
        -:  295:
        -:  296:    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;
        -:  297:    template <class T>
        -:  298:        size_type find_first_not_of(const T& t, size_type pos = 0) const noexcept; // C++17, noexcept as an extension
        -:  299:    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;
        -:  300:    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;
        -:  301:    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;
        -:  302:
        -:  303:    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;
        -:  304:    template <class T>
        -:  305:        size_type find_last_not_of(const T& t, size_type pos = npos) const noexcept; // C++17, noexcept as an extension
        -:  306:    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;
        -:  307:    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;
        -:  308:    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;
        -:  309:
        -:  310:    int compare(const basic_string& str) const noexcept;
        -:  311:    template <class T>
        -:  312:        int compare(const T& t) const noexcept;  // C++17, noexcept as an extension
        -:  313:    int compare(size_type pos1, size_type n1, const basic_string& str) const;
        -:  314:    template <class T>
        -:  315:        int compare(size_type pos1, size_type n1, const T& t) const;  // C++17
        -:  316:    int compare(size_type pos1, size_type n1, const basic_string& str,
        -:  317:                size_type pos2, size_type n2=npos) const; // C++14
        -:  318:    template <class T>
        -:  319:        int compare(size_type pos1, size_type n1, const T& t,
        -:  320:                    size_type pos2, size_type n2=npos) const; // C++17
        -:  321:    int compare(const value_type* s) const noexcept;
        -:  322:    int compare(size_type pos1, size_type n1, const value_type* s) const;
        -:  323:    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;
        -:  324:
        -:  325:    bool starts_with(basic_string_view<charT, traits> sv) const noexcept; // C++20
        -:  326:    bool starts_with(charT c) const noexcept;                             // C++20
        -:  327:    bool starts_with(const charT* s) const;                               // C++20
        -:  328:    bool ends_with(basic_string_view<charT, traits> sv) const noexcept;   // C++20
        -:  329:    bool ends_with(charT c) const noexcept;                               // C++20
        -:  330:    bool ends_with(const charT* s) const;                                 // C++20
        -:  331:
        -:  332:    constexpr bool contains(basic_string_view<charT, traits> sv) const noexcept; // C++2b
        -:  333:    constexpr bool contains(charT c) const noexcept;                             // C++2b
        -:  334:    constexpr bool contains(const charT* s) const;                               // C++2b
        -:  335:
        -:  336:    bool __invariants() const;
        -:  337:};
        -:  338:
        -:  339:template<class InputIterator,
        -:  340:         class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>
        -:  341:basic_string(InputIterator, InputIterator, Allocator = Allocator())
        -:  342:   -> basic_string<typename iterator_traits<InputIterator>::value_type,
        -:  343:                  char_traits<typename iterator_traits<InputIterator>::value_type>,
        -:  344:                  Allocator>;   // C++17
        -:  345:
        -:  346:template<class charT, class traits, class Allocator>
        -:  347:basic_string<charT, traits, Allocator>
        -:  348:operator+(const basic_string<charT, traits, Allocator>& lhs,
        -:  349:          const basic_string<charT, traits, Allocator>& rhs);
        -:  350:
        -:  351:template<class charT, class traits, class Allocator>
        -:  352:basic_string<charT, traits, Allocator>
        -:  353:operator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);
        -:  354:
        -:  355:template<class charT, class traits, class Allocator>
        -:  356:basic_string<charT, traits, Allocator>
        -:  357:operator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);
        -:  358:
        -:  359:template<class charT, class traits, class Allocator>
        -:  360:basic_string<charT, traits, Allocator>
        -:  361:operator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);
        -:  362:
        -:  363:template<class charT, class traits, class Allocator>
        -:  364:basic_string<charT, traits, Allocator>
        -:  365:operator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);
        -:  366:
        -:  367:template<class charT, class traits, class Allocator>
        -:  368:bool operator==(const basic_string<charT, traits, Allocator>& lhs,
        -:  369:                const basic_string<charT, traits, Allocator>& rhs) noexcept;
        -:  370:
        -:  371:template<class charT, class traits, class Allocator>
        -:  372:bool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;
        -:  373:
        -:  374:template<class charT, class traits, class Allocator>
        -:  375:bool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;
        -:  376:
        -:  377:template<class charT, class traits, class Allocator>
        -:  378:bool operator!=(const basic_string<charT,traits,Allocator>& lhs,
        -:  379:                const basic_string<charT, traits, Allocator>& rhs) noexcept;
        -:  380:
        -:  381:template<class charT, class traits, class Allocator>
        -:  382:bool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;
        -:  383:
        -:  384:template<class charT, class traits, class Allocator>
        -:  385:bool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;
        -:  386:
        -:  387:template<class charT, class traits, class Allocator>
        -:  388:bool operator< (const basic_string<charT, traits, Allocator>& lhs,
        -:  389:                const basic_string<charT, traits, Allocator>& rhs) noexcept;
        -:  390:
        -:  391:template<class charT, class traits, class Allocator>
        -:  392:bool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;
        -:  393:
        -:  394:template<class charT, class traits, class Allocator>
        -:  395:bool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;
        -:  396:
        -:  397:template<class charT, class traits, class Allocator>
        -:  398:bool operator> (const basic_string<charT, traits, Allocator>& lhs,
        -:  399:                const basic_string<charT, traits, Allocator>& rhs) noexcept;
        -:  400:
        -:  401:template<class charT, class traits, class Allocator>
        -:  402:bool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;
        -:  403:
        -:  404:template<class charT, class traits, class Allocator>
        -:  405:bool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;
        -:  406:
        -:  407:template<class charT, class traits, class Allocator>
        -:  408:bool operator<=(const basic_string<charT, traits, Allocator>& lhs,
        -:  409:                const basic_string<charT, traits, Allocator>& rhs) noexcept;
        -:  410:
        -:  411:template<class charT, class traits, class Allocator>
        -:  412:bool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;
        -:  413:
        -:  414:template<class charT, class traits, class Allocator>
        -:  415:bool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;
        -:  416:
        -:  417:template<class charT, class traits, class Allocator>
        -:  418:bool operator>=(const basic_string<charT, traits, Allocator>& lhs,
        -:  419:                const basic_string<charT, traits, Allocator>& rhs) noexcept;
        -:  420:
        -:  421:template<class charT, class traits, class Allocator>
        -:  422:bool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;
        -:  423:
        -:  424:template<class charT, class traits, class Allocator>
        -:  425:bool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;
        -:  426:
        -:  427:template<class charT, class traits, class Allocator>
        -:  428:void swap(basic_string<charT, traits, Allocator>& lhs,
        -:  429:          basic_string<charT, traits, Allocator>& rhs)
        -:  430:            noexcept(noexcept(lhs.swap(rhs)));
        -:  431:
        -:  432:template<class charT, class traits, class Allocator>
        -:  433:basic_istream<charT, traits>&
        -:  434:operator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);
        -:  435:
        -:  436:template<class charT, class traits, class Allocator>
        -:  437:basic_ostream<charT, traits>&
        -:  438:operator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);
        -:  439:
        -:  440:template<class charT, class traits, class Allocator>
        -:  441:basic_istream<charT, traits>&
        -:  442:getline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,
        -:  443:        charT delim);
        -:  444:
        -:  445:template<class charT, class traits, class Allocator>
        -:  446:basic_istream<charT, traits>&
        -:  447:getline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);
        -:  448:
        -:  449:template<class charT, class traits, class Allocator, class U>
        -:  450:typename basic_string<charT, traits, Allocator>::size_type
        -:  451:erase(basic_string<charT, traits, Allocator>& c, const U& value);    // C++20
        -:  452:template<class charT, class traits, class Allocator, class Predicate>
        -:  453:typename basic_string<charT, traits, Allocator>::size_type
        -:  454:erase_if(basic_string<charT, traits, Allocator>& c, Predicate pred); // C++20
        -:  455:
        -:  456:typedef basic_string<char>    string;
        -:  457:typedef basic_string<wchar_t> wstring;
        -:  458:typedef basic_string<char8_t> u8string; // C++20
        -:  459:typedef basic_string<char16_t> u16string;
        -:  460:typedef basic_string<char32_t> u32string;
        -:  461:
        -:  462:int                stoi  (const string& str, size_t* idx = nullptr, int base = 10);
        -:  463:long               stol  (const string& str, size_t* idx = nullptr, int base = 10);
        -:  464:unsigned long      stoul (const string& str, size_t* idx = nullptr, int base = 10);
        -:  465:long long          stoll (const string& str, size_t* idx = nullptr, int base = 10);
        -:  466:unsigned long long stoull(const string& str, size_t* idx = nullptr, int base = 10);
        -:  467:
        -:  468:float       stof (const string& str, size_t* idx = nullptr);
        -:  469:double      stod (const string& str, size_t* idx = nullptr);
        -:  470:long double stold(const string& str, size_t* idx = nullptr);
        -:  471:
        -:  472:string to_string(int val);
        -:  473:string to_string(unsigned val);
        -:  474:string to_string(long val);
        -:  475:string to_string(unsigned long val);
        -:  476:string to_string(long long val);
        -:  477:string to_string(unsigned long long val);
        -:  478:string to_string(float val);
        -:  479:string to_string(double val);
        -:  480:string to_string(long double val);
        -:  481:
        -:  482:int                stoi  (const wstring& str, size_t* idx = nullptr, int base = 10);
        -:  483:long               stol  (const wstring& str, size_t* idx = nullptr, int base = 10);
        -:  484:unsigned long      stoul (const wstring& str, size_t* idx = nullptr, int base = 10);
        -:  485:long long          stoll (const wstring& str, size_t* idx = nullptr, int base = 10);
        -:  486:unsigned long long stoull(const wstring& str, size_t* idx = nullptr, int base = 10);
        -:  487:
        -:  488:float       stof (const wstring& str, size_t* idx = nullptr);
        -:  489:double      stod (const wstring& str, size_t* idx = nullptr);
        -:  490:long double stold(const wstring& str, size_t* idx = nullptr);
        -:  491:
        -:  492:wstring to_wstring(int val);
        -:  493:wstring to_wstring(unsigned val);
        -:  494:wstring to_wstring(long val);
        -:  495:wstring to_wstring(unsigned long val);
        -:  496:wstring to_wstring(long long val);
        -:  497:wstring to_wstring(unsigned long long val);
        -:  498:wstring to_wstring(float val);
        -:  499:wstring to_wstring(double val);
        -:  500:wstring to_wstring(long double val);
        -:  501:
        -:  502:template <> struct hash<string>;
        -:  503:template <> struct hash<u8string>; // C++20
        -:  504:template <> struct hash<u16string>;
        -:  505:template <> struct hash<u32string>;
        -:  506:template <> struct hash<wstring>;
        -:  507:
        -:  508:basic_string<char>     operator "" s( const char *str,     size_t len ); // C++14
        -:  509:basic_string<wchar_t>  operator "" s( const wchar_t *str,  size_t len ); // C++14
        -:  510:basic_string<char8_t>  operator "" s( const char8_t *str,  size_t len ); // C++20
        -:  511:basic_string<char16_t> operator "" s( const char16_t *str, size_t len ); // C++14
        -:  512:basic_string<char32_t> operator "" s( const char32_t *str, size_t len ); // C++14
        -:  513:
        -:  514:}  // std
        -:  515:
        -:  516:*/
        -:  517:
        -:  518:#include <__config>
        -:  519:#include <__debug>
        -:  520:#include <__functional_base>
        -:  521:#include <__iterator/wrap_iter.h>
        -:  522:#include <algorithm>
        -:  523:#include <compare>
        -:  524:#include <cstdio>  // EOF
        -:  525:#include <cstdlib>
        -:  526:#include <cstring>
        -:  527:#include <initializer_list>
        -:  528:#include <iosfwd>
        -:  529:#include <iterator>
        -:  530:#include <memory>
        -:  531:#include <stdexcept>
        -:  532:#include <string_view>
        -:  533:#include <type_traits>
        -:  534:#include <utility>
        -:  535:#include <version>
        -:  536:
        -:  537:#ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -:  538:#   include <cwchar>
        -:  539:#endif
        -:  540:
        -:  541:#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
        -:  542:# include <cstdint>
        -:  543:#endif
        -:  544:
        -:  545:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  546:#pragma GCC system_header
        -:  547:#endif
        -:  548:
        -:  549:_LIBCPP_PUSH_MACROS
        -:  550:#include <__undef_macros>
        -:  551:
        -:  552:
        -:  553:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  554:
        -:  555:// fpos
        -:  556:
        -:  557:template <class _StateT>
        -:  558:class _LIBCPP_TEMPLATE_VIS fpos
        -:  559:{
        -:  560:private:
        -:  561:    _StateT __st_;
        -:  562:    streamoff __off_;
        -:  563:public:
        -:  564:    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}
        -:  565:
        -:  566:    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}
        -:  567:
        -:  568:    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}
        -:  569:    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}
        -:  570:
        -:  571:    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}
        -:  572:    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}
        -:  573:    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}
        -:  574:    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}
        -:  575:};
        -:  576:
        -:  577:template <class _StateT>
        -:  578:inline _LIBCPP_INLINE_VISIBILITY
        -:  579:streamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
        -:  580:    {return streamoff(__x) - streamoff(__y);}
        -:  581:
        -:  582:template <class _StateT>
        -:  583:inline _LIBCPP_INLINE_VISIBILITY
        -:  584:bool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
        -:  585:    {return streamoff(__x) == streamoff(__y);}
        -:  586:
        -:  587:template <class _StateT>
        -:  588:inline _LIBCPP_INLINE_VISIBILITY
        -:  589:bool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
        -:  590:    {return streamoff(__x) != streamoff(__y);}
        -:  591:
        -:  592:// basic_string
        -:  593:
        -:  594:template<class _CharT, class _Traits, class _Allocator>
        -:  595:basic_string<_CharT, _Traits, _Allocator>
        -:  596:operator+(const basic_string<_CharT, _Traits, _Allocator>& __x,
        -:  597:          const basic_string<_CharT, _Traits, _Allocator>& __y);
        -:  598:
        -:  599:template<class _CharT, class _Traits, class _Allocator>
        -:  600:basic_string<_CharT, _Traits, _Allocator>
        -:  601:operator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);
        -:  602:
        -:  603:template<class _CharT, class _Traits, class _Allocator>
        -:  604:basic_string<_CharT, _Traits, _Allocator>
        -:  605:operator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);
        -:  606:
        -:  607:template<class _CharT, class _Traits, class _Allocator>
        -:  608:inline _LIBCPP_INLINE_VISIBILITY
        -:  609:basic_string<_CharT, _Traits, _Allocator>
        -:  610:operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);
        -:  611:
        -:  612:template<class _CharT, class _Traits, class _Allocator>
        -:  613:basic_string<_CharT, _Traits, _Allocator>
        -:  614:operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);
        -:  615:
        -:  616:_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))
        -:  617:
        -:  618:template <bool>
        -:  619:class _LIBCPP_TEMPLATE_VIS __basic_string_common
        -:  620:{
        -:  621:protected:
        -:  622:    _LIBCPP_NORETURN void __throw_length_error() const;
        -:  623:    _LIBCPP_NORETURN void __throw_out_of_range() const;
        -:  624:};
        -:  625:
        -:  626:template <bool __b>
        -:  627:void
        -:  628:__basic_string_common<__b>::__throw_length_error() const
        -:  629:{
        -:  630:    _VSTD::__throw_length_error("basic_string");
        -:  631:}
        -:  632:
        -:  633:template <bool __b>
        -:  634:void
        -:  635:__basic_string_common<__b>::__throw_out_of_range() const
        -:  636:{
        -:  637:    _VSTD::__throw_out_of_range("basic_string");
        -:  638:}
        -:  639:
        -:  640:_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __basic_string_common<true>)
        -:  641:
        -:  642:template <class _Iter>
        -:  643:struct __string_is_trivial_iterator : public false_type {};
        -:  644:
        -:  645:template <class _Tp>
        -:  646:struct __string_is_trivial_iterator<_Tp*>
        -:  647:    : public is_arithmetic<_Tp> {};
        -:  648:
        -:  649:template <class _Iter>
        -:  650:struct __string_is_trivial_iterator<__wrap_iter<_Iter> >
        -:  651:    : public __string_is_trivial_iterator<_Iter> {};
        -:  652:
        -:  653:template <class _CharT, class _Traits, class _Tp>
        -:  654:struct __can_be_converted_to_string_view : public _BoolConstant<
        -:  655:      is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&
        -:  656:     !is_convertible<const _Tp&, const _CharT*>::value
        -:  657:    > {};
        -:  658:
        -:  659:#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
        -:  660:
        -:  661:template <class _CharT, size_t = sizeof(_CharT)>
        -:  662:struct __padding
        -:  663:{
        -:  664:    unsigned char __xx[sizeof(_CharT)-1];
        -:  665:};
        -:  666:
        -:  667:template <class _CharT>
        -:  668:struct __padding<_CharT, 1>
        -:  669:{
        -:  670:};
        -:  671:
        -:  672:#endif // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
        -:  673:
        -:  674:#ifndef _LIBCPP_HAS_NO_CHAR8_T
        -:  675:typedef basic_string<char8_t> u8string;
        -:  676:#endif
        -:  677:
        -:  678:#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
        -:  679:typedef basic_string<char16_t> u16string;
        -:  680:typedef basic_string<char32_t> u32string;
        -:  681:#endif // _LIBCPP_HAS_NO_UNICODE_CHARS
        -:  682:
        -:  683:template<class _CharT, class _Traits, class _Allocator>
        -:  684:class
        -:  685:    _LIBCPP_TEMPLATE_VIS
        -:  686:#ifndef _LIBCPP_HAS_NO_CHAR8_T
        -:  687:    _LIBCPP_PREFERRED_NAME(u8string)
        -:  688:#endif
        -:  689:#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
        -:  690:    _LIBCPP_PREFERRED_NAME(u16string)
        -:  691:    _LIBCPP_PREFERRED_NAME(u32string)
        -:  692:#endif
        -:  693:    basic_string
        -:  694:    : private __basic_string_common<true>
        -:  695:{
        -:  696:public:
        -:  697:    typedef basic_string                                 __self;
        -:  698:    typedef basic_string_view<_CharT, _Traits>           __self_view;
        -:  699:    typedef _Traits                                      traits_type;
        -:  700:    typedef _CharT                                       value_type;
        -:  701:    typedef _Allocator                                   allocator_type;
        -:  702:    typedef allocator_traits<allocator_type>             __alloc_traits;
        -:  703:    typedef typename __alloc_traits::size_type           size_type;
        -:  704:    typedef typename __alloc_traits::difference_type     difference_type;
        -:  705:    typedef value_type&                                  reference;
        -:  706:    typedef const value_type&                            const_reference;
        -:  707:    typedef typename __alloc_traits::pointer             pointer;
        -:  708:    typedef typename __alloc_traits::const_pointer       const_pointer;
        -:  709:
        -:  710:    static_assert((!is_array<value_type>::value), "Character type of basic_string must not be an array");
        -:  711:    static_assert(( is_standard_layout<value_type>::value), "Character type of basic_string must be standard-layout");
        -:  712:    static_assert(( is_trivial<value_type>::value), "Character type of basic_string must be trivial");
        -:  713:    static_assert(( is_same<_CharT, typename traits_type::char_type>::value),
        -:  714:                  "traits_type::char_type must be the same type as CharT");
        -:  715:    static_assert(( is_same<typename allocator_type::value_type, value_type>::value),
        -:  716:                  "Allocator::value_type must be same type as value_type");
        -:  717:
        -:  718:    typedef __wrap_iter<pointer>                         iterator;
        -:  719:    typedef __wrap_iter<const_pointer>                   const_iterator;
        -:  720:    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;
        -:  721:    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;
        -:  722:
        -:  723:private:
        -:  724:
        -:  725:#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
        -:  726:
        -:  727:    struct __long
        -:  728:    {
        -:  729:        pointer   __data_;
        -:  730:        size_type __size_;
        -:  731:        size_type __cap_;
        -:  732:    };
        -:  733:
        -:  734:#ifdef _LIBCPP_BIG_ENDIAN
        -:  735:    static const size_type __short_mask = 0x01;
        -:  736:    static const size_type __long_mask  = 0x1ul;
        -:  737:#else  // _LIBCPP_BIG_ENDIAN
        -:  738:    static const size_type __short_mask = 0x80;
        -:  739:    static const size_type __long_mask  = ~(size_type(~0) >> 1);
        -:  740:#endif // _LIBCPP_BIG_ENDIAN
        -:  741:
        -:  742:    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
        -:  743:                      (sizeof(__long) - 1)/sizeof(value_type) : 2};
        -:  744:
        -:  745:    struct __short
        -:  746:    {
        -:  747:        value_type __data_[__min_cap];
        -:  748:        struct
        -:  749:            : __padding<value_type>
        -:  750:        {
        -:  751:            unsigned char __size_;
        -:  752:        };
        -:  753:    };
        -:  754:
        -:  755:#else
        -:  756:
        -:  757:    struct __long
        -:  758:    {
        -:  759:        size_type __cap_;
        -:  760:        size_type __size_;
        -:  761:        pointer   __data_;
        -:  762:    };
        -:  763:
        -:  764:#ifdef _LIBCPP_BIG_ENDIAN
        -:  765:    static const size_type __short_mask = 0x80;
        -:  766:    static const size_type __long_mask  = ~(size_type(~0) >> 1);
        -:  767:#else  // _LIBCPP_BIG_ENDIAN
        -:  768:    static const size_type __short_mask = 0x01;
        -:  769:    static const size_type __long_mask  = 0x1ul;
        -:  770:#endif // _LIBCPP_BIG_ENDIAN
        -:  771:
        -:  772:    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
        -:  773:                      (sizeof(__long) - 1)/sizeof(value_type) : 2};
        -:  774:
        -:  775:    struct __short
        -:  776:    {
        -:  777:        union
        -:  778:        {
        -:  779:            unsigned char __size_;
        -:  780:            value_type __lx;
        -:  781:        };
        -:  782:        value_type __data_[__min_cap];
        -:  783:    };
        -:  784:
        -:  785:#endif // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
        -:  786:
        -:  787:    union __ulx{__long __lx; __short __lxx;};
        -:  788:
        -:  789:    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};
        -:  790:
        -:  791:    struct __raw
        -:  792:    {
        -:  793:        size_type __words[__n_words];
        -:  794:    };
        -:  795:
        -:  796:    struct __rep
        -:  797:    {
        -:  798:        union
        -:  799:        {
        -:  800:            __long  __l;
        -:  801:            __short __s;
        -:  802:            __raw   __r;
        -:  803:        };
        -:  804:    };
        -:  805:
        -:  806:    __compressed_pair<__rep, allocator_type> __r_;
        -:  807:
        -:  808:public:
        -:  809:    _LIBCPP_TEMPLATE_DATA_VIS
        -:  810:    static const size_type npos = -1;
        -:  811:
        -:  812:    _LIBCPP_INLINE_VISIBILITY basic_string()
        -:  813:        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);
        -:  814:
        -:  815:    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)
        -:  816:#if _LIBCPP_STD_VER <= 14
        -:  817:        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);
        -:  818:#else
        -:  819:        _NOEXCEPT;
        -:  820:#endif
        -:  821:
        -:  822:    basic_string(const basic_string& __str);
        -:  823:    basic_string(const basic_string& __str, const allocator_type& __a);
        -:  824:
        -:  825:#ifndef _LIBCPP_CXX03_LANG
        -:  826:    _LIBCPP_INLINE_VISIBILITY
        -:  827:    basic_string(basic_string&& __str)
        -:  828:#if _LIBCPP_STD_VER <= 14
        -:  829:        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);
        -:  830:#else
        -:  831:        _NOEXCEPT;
        -:  832:#endif
        -:  833:
        -:  834:    _LIBCPP_INLINE_VISIBILITY
        -:  835:    basic_string(basic_string&& __str, const allocator_type& __a);
        -:  836:#endif // _LIBCPP_CXX03_LANG
        -:  837:
        -:  838:    template <class = _EnableIf<__is_allocator<_Allocator>::value, nullptr_t> >
        -:  839:    _LIBCPP_INLINE_VISIBILITY
function _ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1IDnEEPKc called 1 returned 100% blocks executed 100%
function _ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC2IDnEEPKc called 1 returned 100% blocks executed 100%
        2:  840:    basic_string(const _CharT* __s) : __r_(__default_init_tag(), __default_init_tag()) {
        -:  841:      _LIBCPP_ASSERT(__s != nullptr, "basic_string(const char*) detected nullptr");
        1:  842:      __init(__s, traits_type::length(__s));
        -:  843:#   if _LIBCPP_DEBUG_LEVEL == 2
        -:  844:      __get_db()->__insert_c(this);
        -:  845:#   endif
        2:  846:    }
        1:  846-block  0
        1:  846-block  1
        -:  847:
        -:  848:    template <class = _EnableIf<__is_allocator<_Allocator>::value, nullptr_t> >
        -:  849:        _LIBCPP_INLINE_VISIBILITY
        -:  850:        basic_string(const _CharT* __s, const _Allocator& __a);
        -:  851:
        -:  852:#if _LIBCPP_STD_VER > 20
        -:  853:    basic_string(nullptr_t) = delete;
        -:  854:#endif
        -:  855:
        -:  856:    _LIBCPP_INLINE_VISIBILITY
        -:  857:    basic_string(const _CharT* __s, size_type __n);
        -:  858:    _LIBCPP_INLINE_VISIBILITY
        -:  859:    basic_string(const _CharT* __s, size_type __n, const _Allocator& __a);
        -:  860:    _LIBCPP_INLINE_VISIBILITY
        -:  861:    basic_string(size_type __n, _CharT __c);
        -:  862:
        -:  863:    template <class = _EnableIf<__is_allocator<_Allocator>::value, nullptr_t> >
        -:  864:        _LIBCPP_INLINE_VISIBILITY
        -:  865:        basic_string(size_type __n, _CharT __c, const _Allocator& __a);
        -:  866:
        -:  867:    basic_string(const basic_string& __str, size_type __pos, size_type __n,
        -:  868:                 const _Allocator& __a = _Allocator());
        -:  869:    _LIBCPP_INLINE_VISIBILITY
        -:  870:    basic_string(const basic_string& __str, size_type __pos,
        -:  871:                 const _Allocator& __a = _Allocator());
        -:  872:
        -:  873:    template<class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
        -:  874:        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -:  875:        basic_string(const _Tp& __t, size_type __pos, size_type __n,
        -:  876:                     const allocator_type& __a = allocator_type());
        -:  877:
        -:  878:    template<class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
        -:  879:                                          !__is_same_uncvref<_Tp, basic_string>::value> >
        -:  880:        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -:  881:        explicit basic_string(const _Tp& __t);
        -:  882:
        -:  883:    template<class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
        -:  884:        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -:  885:        explicit basic_string(const _Tp& __t, const allocator_type& __a);
        -:  886:
        -:  887:    template<class _InputIterator, class = _EnableIf<__is_cpp17_input_iterator<_InputIterator>::value> >
        -:  888:        _LIBCPP_INLINE_VISIBILITY
        -:  889:        basic_string(_InputIterator __first, _InputIterator __last);
        -:  890:    template<class _InputIterator, class = _EnableIf<__is_cpp17_input_iterator<_InputIterator>::value> >
        -:  891:        _LIBCPP_INLINE_VISIBILITY
        -:  892:        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);
        -:  893:#ifndef _LIBCPP_CXX03_LANG
        -:  894:    _LIBCPP_INLINE_VISIBILITY
        -:  895:    basic_string(initializer_list<_CharT> __il);
        -:  896:    _LIBCPP_INLINE_VISIBILITY
        -:  897:    basic_string(initializer_list<_CharT> __il, const _Allocator& __a);
        -:  898:#endif // _LIBCPP_CXX03_LANG
        -:  899:
        -:  900:    inline ~basic_string();
        -:  901:
        -:  902:    _LIBCPP_INLINE_VISIBILITY
        -:  903:    operator __self_view() const _NOEXCEPT { return __self_view(data(), size()); }
        -:  904:
        -:  905:    basic_string& operator=(const basic_string& __str);
        -:  906:
        -:  907:    template <class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
        -:  908:    basic_string& operator=(const _Tp& __t)
        -:  909:        {__self_view __sv = __t; return assign(__sv);}
        -:  910:
        -:  911:#ifndef _LIBCPP_CXX03_LANG
        -:  912:    _LIBCPP_INLINE_VISIBILITY
        -:  913:    basic_string& operator=(basic_string&& __str)
        -:  914:        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));
        -:  915:     _LIBCPP_INLINE_VISIBILITY
        -:  916:    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}
        -:  917:#endif
        -:  918:    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}
        -:  919:#if _LIBCPP_STD_VER > 20
        -:  920:    basic_string& operator=(nullptr_t) = delete;
        -:  921:#endif
        -:  922:    basic_string& operator=(value_type __c);
        -:  923:
        -:  924:#if _LIBCPP_DEBUG_LEVEL == 2
        -:  925:    _LIBCPP_INLINE_VISIBILITY
        -:  926:    iterator begin() _NOEXCEPT
        -:  927:        {return iterator(this, __get_pointer());}
        -:  928:    _LIBCPP_INLINE_VISIBILITY
        -:  929:    const_iterator begin() const _NOEXCEPT
        -:  930:        {return const_iterator(this, __get_pointer());}
        -:  931:    _LIBCPP_INLINE_VISIBILITY
        -:  932:    iterator end() _NOEXCEPT
        -:  933:        {return iterator(this, __get_pointer() + size());}
        -:  934:    _LIBCPP_INLINE_VISIBILITY
        -:  935:    const_iterator end() const _NOEXCEPT
        -:  936:        {return const_iterator(this, __get_pointer() + size());}
        -:  937:#else
        -:  938:    _LIBCPP_INLINE_VISIBILITY
        -:  939:    iterator begin() _NOEXCEPT
        -:  940:        {return iterator(__get_pointer());}
        -:  941:    _LIBCPP_INLINE_VISIBILITY
        -:  942:    const_iterator begin() const _NOEXCEPT
        -:  943:        {return const_iterator(__get_pointer());}
        -:  944:    _LIBCPP_INLINE_VISIBILITY
        -:  945:    iterator end() _NOEXCEPT
        -:  946:        {return iterator(__get_pointer() + size());}
        -:  947:    _LIBCPP_INLINE_VISIBILITY
        -:  948:    const_iterator end() const _NOEXCEPT
        -:  949:        {return const_iterator(__get_pointer() + size());}
        -:  950:#endif // _LIBCPP_DEBUG_LEVEL == 2
        -:  951:    _LIBCPP_INLINE_VISIBILITY
        -:  952:    reverse_iterator rbegin() _NOEXCEPT
        -:  953:        {return reverse_iterator(end());}
        -:  954:    _LIBCPP_INLINE_VISIBILITY
        -:  955:    const_reverse_iterator rbegin() const _NOEXCEPT
        -:  956:        {return const_reverse_iterator(end());}
        -:  957:    _LIBCPP_INLINE_VISIBILITY
        -:  958:    reverse_iterator rend() _NOEXCEPT
        -:  959:        {return reverse_iterator(begin());}
        -:  960:    _LIBCPP_INLINE_VISIBILITY
        -:  961:    const_reverse_iterator rend() const _NOEXCEPT
        -:  962:        {return const_reverse_iterator(begin());}
        -:  963:
        -:  964:    _LIBCPP_INLINE_VISIBILITY
        -:  965:    const_iterator cbegin() const _NOEXCEPT
        -:  966:        {return begin();}
        -:  967:    _LIBCPP_INLINE_VISIBILITY
        -:  968:    const_iterator cend() const _NOEXCEPT
        -:  969:        {return end();}
        -:  970:    _LIBCPP_INLINE_VISIBILITY
        -:  971:    const_reverse_iterator crbegin() const _NOEXCEPT
        -:  972:        {return rbegin();}
        -:  973:    _LIBCPP_INLINE_VISIBILITY
        -:  974:    const_reverse_iterator crend() const _NOEXCEPT
        -:  975:        {return rend();}
        -:  976:
        -:  977:    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT
        -:  978:        {return __is_long() ? __get_long_size() : __get_short_size();}
        -:  979:    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}
        -:  980:    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;
        -:  981:    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT
        -:  982:        {return (__is_long() ? __get_long_cap()
        -:  983:                             : static_cast<size_type>(__min_cap)) - 1;}
        -:  984:
        -:  985:    void resize(size_type __n, value_type __c);
        -:  986:    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}
        -:  987:
        -:  988:    void reserve(size_type __requested_capacity);
        -:  989:    _LIBCPP_INLINE_VISIBILITY void __resize_default_init(size_type __n);
        -:  990:
        -:  991:    _LIBCPP_DEPRECATED_IN_CXX20 _LIBCPP_INLINE_VISIBILITY
        -:  992:    void reserve() _NOEXCEPT {shrink_to_fit();}
        -:  993:    _LIBCPP_INLINE_VISIBILITY
        -:  994:    void shrink_to_fit() _NOEXCEPT;
        -:  995:    _LIBCPP_INLINE_VISIBILITY
        -:  996:    void clear() _NOEXCEPT;
        -:  997:    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY
        -:  998:    bool empty() const _NOEXCEPT {return size() == 0;}
        -:  999:
        -: 1000:    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const _NOEXCEPT;
        -: 1001:    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos)       _NOEXCEPT;
        -: 1002:
        -: 1003:    const_reference at(size_type __n) const;
        -: 1004:    reference       at(size_type __n);
        -: 1005:
        -: 1006:    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}
        -: 1007:
        -: 1008:    template <class _Tp>
        -: 1009:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1010:    _EnableIf
        -: 1011:        <
        -: 1012:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
        -: 1013:            && !__is_same_uncvref<_Tp, basic_string >::value,
        -: 1014:            basic_string&
        -: 1015:        >
        -: 1016:                                            operator+=(const _Tp& __t)            {__self_view __sv = __t; return append(__sv);}
        -: 1017:    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)     {return append(__s);}
        -: 1018:    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}
        -: 1019:#ifndef _LIBCPP_CXX03_LANG
        -: 1020:    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}
        -: 1021:#endif // _LIBCPP_CXX03_LANG
        -: 1022:
        -: 1023:    _LIBCPP_INLINE_VISIBILITY
        -: 1024:    basic_string& append(const basic_string& __str);
        -: 1025:
        -: 1026:    template <class _Tp>
        -: 1027:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1028:    _EnableIf<
        -: 1029:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
        -: 1030:            && !__is_same_uncvref<_Tp, basic_string>::value,
        -: 1031:            basic_string&
        -: 1032:        >
        -: 1033:                  append(const _Tp& __t) { __self_view __sv = __t; return append(__sv.data(), __sv.size()); }
        -: 1034:    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);
        -: 1035:
        -: 1036:    template <class _Tp>
        -: 1037:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1038:    _EnableIf
        -: 1039:        <
        -: 1040:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
        -: 1041:            && !__is_same_uncvref<_Tp, basic_string>::value,
        -: 1042:            basic_string&
        -: 1043:        >
        -: 1044:                  append(const _Tp& __t, size_type __pos, size_type __n=npos);
        -: 1045:    basic_string& append(const value_type* __s, size_type __n);
        -: 1046:    basic_string& append(const value_type* __s);
        -: 1047:    basic_string& append(size_type __n, value_type __c);
        -: 1048:
        -: 1049:    _LIBCPP_INLINE_VISIBILITY
        -: 1050:    void __append_default_init(size_type __n);
        -: 1051:
        -: 1052:    template<class _InputIterator>
        -: 1053:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1054:    _EnableIf
        -: 1055:        <
        -: 1056:            __is_exactly_cpp17_input_iterator<_InputIterator>::value,
        -: 1057:            basic_string&
        -: 1058:        >
        -: 1059:    _LIBCPP_INLINE_VISIBILITY
        -: 1060:    append(_InputIterator __first, _InputIterator __last) {
        -: 1061:      const basic_string __temp(__first, __last, __alloc());
        -: 1062:      append(__temp.data(), __temp.size());
        -: 1063:      return *this;
        -: 1064:    }
        -: 1065:    template<class _ForwardIterator>
        -: 1066:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1067:    _EnableIf
        -: 1068:        <
        -: 1069:            __is_cpp17_forward_iterator<_ForwardIterator>::value,
        -: 1070:            basic_string&
        -: 1071:        >
        -: 1072:    _LIBCPP_INLINE_VISIBILITY
        -: 1073:    append(_ForwardIterator __first, _ForwardIterator __last);
        -: 1074:
        -: 1075:#ifndef _LIBCPP_CXX03_LANG
        -: 1076:    _LIBCPP_INLINE_VISIBILITY
        -: 1077:    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}
        -: 1078:#endif // _LIBCPP_CXX03_LANG
        -: 1079:
        -: 1080:    void push_back(value_type __c);
        -: 1081:    _LIBCPP_INLINE_VISIBILITY
        -: 1082:    void pop_back();
        -: 1083:    _LIBCPP_INLINE_VISIBILITY reference       front() _NOEXCEPT;
        -: 1084:    _LIBCPP_INLINE_VISIBILITY const_reference front() const _NOEXCEPT;
        -: 1085:    _LIBCPP_INLINE_VISIBILITY reference       back() _NOEXCEPT;
        -: 1086:    _LIBCPP_INLINE_VISIBILITY const_reference back() const _NOEXCEPT;
        -: 1087:
        -: 1088:    template <class _Tp>
        -: 1089:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1090:    _EnableIf
        -: 1091:        <
        -: 1092:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 1093:            basic_string&
        -: 1094:        >
        -: 1095:                 assign(const _Tp & __t) { __self_view __sv = __t; return assign(__sv.data(), __sv.size()); }
        -: 1096:    _LIBCPP_INLINE_VISIBILITY
        -: 1097:    basic_string& assign(const basic_string& __str) { return *this = __str; }
        -: 1098:#ifndef _LIBCPP_CXX03_LANG
        -: 1099:    _LIBCPP_INLINE_VISIBILITY
        -: 1100:    basic_string& assign(basic_string&& __str)
        -: 1101:        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
        -: 1102:        {*this = _VSTD::move(__str); return *this;}
        -: 1103:#endif
        -: 1104:    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);
        -: 1105:    template <class _Tp>
        -: 1106:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1107:    _EnableIf
        -: 1108:        <
        -: 1109:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
        -: 1110:            && !__is_same_uncvref<_Tp, basic_string>::value,
        -: 1111:            basic_string&
        -: 1112:        >
        -: 1113:                  assign(const _Tp & __t, size_type __pos, size_type __n=npos);
        -: 1114:    basic_string& assign(const value_type* __s, size_type __n);
        -: 1115:    basic_string& assign(const value_type* __s);
        -: 1116:    basic_string& assign(size_type __n, value_type __c);
        -: 1117:    template<class _InputIterator>
        -: 1118:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1119:    _EnableIf
        -: 1120:        <
        -: 1121:            __is_exactly_cpp17_input_iterator<_InputIterator>::value,
        -: 1122:            basic_string&
        -: 1123:        >
        -: 1124:        assign(_InputIterator __first, _InputIterator __last);
        -: 1125:    template<class _ForwardIterator>
        -: 1126:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1127:    _EnableIf
        -: 1128:        <
        -: 1129:            __is_cpp17_forward_iterator<_ForwardIterator>::value,
        -: 1130:            basic_string&
        -: 1131:        >
        -: 1132:        assign(_ForwardIterator __first, _ForwardIterator __last);
        -: 1133:#ifndef _LIBCPP_CXX03_LANG
        -: 1134:    _LIBCPP_INLINE_VISIBILITY
        -: 1135:    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}
        -: 1136:#endif // _LIBCPP_CXX03_LANG
        -: 1137:
        -: 1138:    _LIBCPP_INLINE_VISIBILITY
        -: 1139:    basic_string& insert(size_type __pos1, const basic_string& __str);
        -: 1140:
        -: 1141:    template <class _Tp>
        -: 1142:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1143:    _EnableIf
        -: 1144:        <
        -: 1145:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 1146:            basic_string&
        -: 1147:        >
        -: 1148:                 insert(size_type __pos1, const _Tp& __t)
        -: 1149:    { __self_view __sv = __t; return insert(__pos1, __sv.data(), __sv.size()); }
        -: 1150:
        -: 1151:    template <class _Tp>
        -: 1152:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1153:    _EnableIf
        -: 1154:        <
        -: 1155:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
        -: 1156:            basic_string&
        -: 1157:        >
        -: 1158:                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);
        -: 1159:    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);
        -: 1160:    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
        -: 1161:    basic_string& insert(size_type __pos, const value_type* __s);
        -: 1162:    basic_string& insert(size_type __pos, size_type __n, value_type __c);
        -: 1163:    iterator      insert(const_iterator __pos, value_type __c);
        -: 1164:    _LIBCPP_INLINE_VISIBILITY
        -: 1165:    iterator      insert(const_iterator __pos, size_type __n, value_type __c);
        -: 1166:    template<class _InputIterator>
        -: 1167:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1168:    _EnableIf
        -: 1169:        <
        -: 1170:            __is_exactly_cpp17_input_iterator<_InputIterator>::value,
        -: 1171:            iterator
        -: 1172:        >
        -: 1173:        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
        -: 1174:    template<class _ForwardIterator>
        -: 1175:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1176:    _EnableIf
        -: 1177:        <
        -: 1178:            __is_cpp17_forward_iterator<_ForwardIterator>::value,
        -: 1179:            iterator
        -: 1180:        >
        -: 1181:        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);
        -: 1182:#ifndef _LIBCPP_CXX03_LANG
        -: 1183:    _LIBCPP_INLINE_VISIBILITY
        -: 1184:    iterator insert(const_iterator __pos, initializer_list<value_type> __il)
        -: 1185:                    {return insert(__pos, __il.begin(), __il.end());}
        -: 1186:#endif // _LIBCPP_CXX03_LANG
        -: 1187:
        -: 1188:    basic_string& erase(size_type __pos = 0, size_type __n = npos);
        -: 1189:    _LIBCPP_INLINE_VISIBILITY
        -: 1190:    iterator      erase(const_iterator __pos);
        -: 1191:    _LIBCPP_INLINE_VISIBILITY
        -: 1192:    iterator      erase(const_iterator __first, const_iterator __last);
        -: 1193:
        -: 1194:    _LIBCPP_INLINE_VISIBILITY
        -: 1195:    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);
        -: 1196:
        -: 1197:    template <class _Tp>
        -: 1198:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1199:    _EnableIf
        -: 1200:        <
        -: 1201:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 1202:            basic_string&
        -: 1203:        >
        -: 1204:                  replace(size_type __pos1, size_type __n1, const _Tp& __t) { __self_view __sv = __t; return replace(__pos1, __n1, __sv.data(), __sv.size()); }
        -: 1205:    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);
        -: 1206:    template <class _Tp>
        -: 1207:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1208:    _EnableIf
        -: 1209:        <
        -: 1210:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value  && !__is_same_uncvref<_Tp, basic_string>::value,
        -: 1211:            basic_string&
        -: 1212:        >
        -: 1213:                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);
        -: 1214:    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
        -: 1215:    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
        -: 1216:    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
        -: 1217:    _LIBCPP_INLINE_VISIBILITY
        -: 1218:    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);
        -: 1219:
        -: 1220:    template <class _Tp>
        -: 1221:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1222:    _EnableIf
        -: 1223:        <
        -: 1224:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 1225:            basic_string&
        -: 1226:        >
        -: 1227:                  replace(const_iterator __i1, const_iterator __i2, const _Tp& __t) { __self_view __sv = __t; return replace(__i1 - begin(), __i2 - __i1, __sv); }
        -: 1228:
        -: 1229:    _LIBCPP_INLINE_VISIBILITY
        -: 1230:    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);
        -: 1231:    _LIBCPP_INLINE_VISIBILITY
        -: 1232:    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);
        -: 1233:    _LIBCPP_INLINE_VISIBILITY
        -: 1234:    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);
        -: 1235:    template<class _InputIterator>
        -: 1236:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1237:    _EnableIf
        -: 1238:        <
        -: 1239:            __is_cpp17_input_iterator<_InputIterator>::value,
        -: 1240:            basic_string&
        -: 1241:        >
        -: 1242:        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);
        -: 1243:#ifndef _LIBCPP_CXX03_LANG
        -: 1244:    _LIBCPP_INLINE_VISIBILITY
        -: 1245:    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)
        -: 1246:        {return replace(__i1, __i2, __il.begin(), __il.end());}
        -: 1247:#endif // _LIBCPP_CXX03_LANG
        -: 1248:
        -: 1249:    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;
        -: 1250:    _LIBCPP_INLINE_VISIBILITY
        -: 1251:    basic_string substr(size_type __pos = 0, size_type __n = npos) const;
        -: 1252:
        -: 1253:    _LIBCPP_INLINE_VISIBILITY
        -: 1254:    void swap(basic_string& __str)
        -: 1255:#if _LIBCPP_STD_VER >= 14
        -: 1256:        _NOEXCEPT;
        -: 1257:#else
        -: 1258:        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||
        -: 1259:                    __is_nothrow_swappable<allocator_type>::value);
        -: 1260:#endif
        -: 1261:
        -: 1262:    _LIBCPP_INLINE_VISIBILITY
function _ZNKSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE5c_strEv called 2 returned 100% blocks executed 100%
        2: 1263:    const value_type* c_str() const _NOEXCEPT {return data();}
        2: 1263-block  0
        -: 1264:    _LIBCPP_INLINE_VISIBILITY
function _ZNKSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4dataEv called 2 returned 100% blocks executed 100%
        2: 1265:    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_address(__get_pointer());}
        2: 1265-block  0
        -: 1266:#if _LIBCPP_STD_VER > 14 || defined(_LIBCPP_BUILDING_LIBRARY)
        -: 1267:    _LIBCPP_INLINE_VISIBILITY
        -: 1268:    value_type* data()             _NOEXCEPT  {return _VSTD::__to_address(__get_pointer());}
        -: 1269:#endif
        -: 1270:
        -: 1271:    _LIBCPP_INLINE_VISIBILITY
        -: 1272:    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}
        -: 1273:
        -: 1274:    _LIBCPP_INLINE_VISIBILITY
        -: 1275:    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;
        -: 1276:
        -: 1277:    template <class _Tp>
        -: 1278:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1279:    _EnableIf
        -: 1280:        <
        -: 1281:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 1282:            size_type
        -: 1283:        >
        -: 1284:              find(const _Tp& __t, size_type __pos = 0) const _NOEXCEPT;
        -: 1285:    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
        -: 1286:    _LIBCPP_INLINE_VISIBILITY
        -: 1287:    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;
        -: 1288:    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;
        -: 1289:
        -: 1290:    _LIBCPP_INLINE_VISIBILITY
        -: 1291:    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;
        -: 1292:
        -: 1293:    template <class _Tp>
        -: 1294:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1295:    _EnableIf
        -: 1296:        <
        -: 1297:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 1298:            size_type
        -: 1299:        >
        -: 1300:              rfind(const _Tp& __t, size_type __pos = npos) const _NOEXCEPT;
        -: 1301:    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
        -: 1302:    _LIBCPP_INLINE_VISIBILITY
        -: 1303:    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;
        -: 1304:    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;
        -: 1305:
        -: 1306:    _LIBCPP_INLINE_VISIBILITY
        -: 1307:    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;
        -: 1308:
        -: 1309:    template <class _Tp>
        -: 1310:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1311:    _EnableIf
        -: 1312:        <
        -: 1313:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 1314:            size_type
        -: 1315:        >
        -: 1316:              find_first_of(const _Tp& __t, size_type __pos = 0) const _NOEXCEPT;
        -: 1317:    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
        -: 1318:    _LIBCPP_INLINE_VISIBILITY
        -: 1319:    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;
        -: 1320:    _LIBCPP_INLINE_VISIBILITY
        -: 1321:    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;
        -: 1322:
        -: 1323:    _LIBCPP_INLINE_VISIBILITY
        -: 1324:    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;
        -: 1325:
        -: 1326:    template <class _Tp>
        -: 1327:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1328:    _EnableIf
        -: 1329:        <
        -: 1330:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 1331:            size_type
        -: 1332:        >
        -: 1333:              find_last_of(const _Tp& __t, size_type __pos = npos) const _NOEXCEPT;
        -: 1334:    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
        -: 1335:    _LIBCPP_INLINE_VISIBILITY
        -: 1336:    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;
        -: 1337:    _LIBCPP_INLINE_VISIBILITY
        -: 1338:    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;
        -: 1339:
        -: 1340:    _LIBCPP_INLINE_VISIBILITY
        -: 1341:    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;
        -: 1342:
        -: 1343:    template <class _Tp>
        -: 1344:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1345:    _EnableIf
        -: 1346:        <
        -: 1347:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 1348:            size_type
        -: 1349:        >
        -: 1350:              find_first_not_of(const _Tp &__t, size_type __pos = 0) const _NOEXCEPT;
        -: 1351:    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
        -: 1352:    _LIBCPP_INLINE_VISIBILITY
        -: 1353:    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;
        -: 1354:    _LIBCPP_INLINE_VISIBILITY
        -: 1355:    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;
        -: 1356:
        -: 1357:    _LIBCPP_INLINE_VISIBILITY
        -: 1358:    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;
        -: 1359:
        -: 1360:    template <class _Tp>
        -: 1361:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1362:    _EnableIf
        -: 1363:        <
        -: 1364:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 1365:            size_type
        -: 1366:        >
        -: 1367:              find_last_not_of(const _Tp& __t, size_type __pos = npos) const _NOEXCEPT;
        -: 1368:    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;
        -: 1369:    _LIBCPP_INLINE_VISIBILITY
        -: 1370:    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;
        -: 1371:    _LIBCPP_INLINE_VISIBILITY
        -: 1372:    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;
        -: 1373:
        -: 1374:    _LIBCPP_INLINE_VISIBILITY
        -: 1375:    int compare(const basic_string& __str) const _NOEXCEPT;
        -: 1376:
        -: 1377:    template <class _Tp>
        -: 1378:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1379:    _EnableIf
        -: 1380:        <
        -: 1381:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 1382:            int
        -: 1383:        >
        -: 1384:        compare(const _Tp &__t) const _NOEXCEPT;
        -: 1385:
        -: 1386:    template <class _Tp>
        -: 1387:    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
        -: 1388:    _EnableIf
        -: 1389:        <
        -: 1390:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 1391:            int
        -: 1392:        >
        -: 1393:         compare(size_type __pos1, size_type __n1, const _Tp& __t) const;
        -: 1394:
        -: 1395:    _LIBCPP_INLINE_VISIBILITY
        -: 1396:    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
        -: 1397:    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;
        -: 1398:
        -: 1399:    template <class _Tp>
        -: 1400:    inline _LIBCPP_INLINE_VISIBILITY
        -: 1401:        _EnableIf
        -: 1402:        <
        -: 1403:            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value  && !__is_same_uncvref<_Tp, basic_string>::value,
        -: 1404:            int
        -: 1405:        >
        -: 1406:        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;
        -: 1407:    int compare(const value_type* __s) const _NOEXCEPT;
        -: 1408:    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
        -: 1409:    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;
        -: 1410:
        -: 1411:#if _LIBCPP_STD_VER > 17
        -: 1412:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -: 1413:    bool starts_with(__self_view __sv) const _NOEXCEPT
        -: 1414:    { return __self_view(data(), size()).starts_with(__sv); }
        -: 1415:
        -: 1416:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -: 1417:    bool starts_with(value_type __c) const _NOEXCEPT
        -: 1418:    { return !empty() && _Traits::eq(front(), __c); }
        -: 1419:
        -: 1420:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -: 1421:    bool starts_with(const value_type* __s) const _NOEXCEPT
        -: 1422:    { return starts_with(__self_view(__s)); }
        -: 1423:
        -: 1424:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -: 1425:    bool ends_with(__self_view __sv) const _NOEXCEPT
        -: 1426:    { return __self_view(data(), size()).ends_with( __sv); }
        -: 1427:
        -: 1428:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -: 1429:    bool ends_with(value_type __c) const _NOEXCEPT
        -: 1430:    { return !empty() && _Traits::eq(back(), __c); }
        -: 1431:
        -: 1432:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -: 1433:    bool ends_with(const value_type* __s) const _NOEXCEPT
        -: 1434:    { return ends_with(__self_view(__s)); }
        -: 1435:#endif
        -: 1436:
        -: 1437:#if _LIBCPP_STD_VER > 20
        -: 1438:    constexpr _LIBCPP_INLINE_VISIBILITY
        -: 1439:    bool contains(__self_view __sv) const noexcept
        -: 1440:    { return __self_view(data(), size()).contains(__sv); }
        -: 1441:
        -: 1442:    constexpr _LIBCPP_INLINE_VISIBILITY
        -: 1443:    bool contains(value_type __c) const noexcept
        -: 1444:    { return __self_view(data(), size()).contains(__c); }
        -: 1445:
        -: 1446:    constexpr _LIBCPP_INLINE_VISIBILITY
        -: 1447:    bool contains(const value_type* __s) const
        -: 1448:    { return __self_view(data(), size()).contains(__s); }
        -: 1449:#endif
        -: 1450:
        -: 1451:    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;
        -: 1452:
        -: 1453:    _LIBCPP_INLINE_VISIBILITY void __clear_and_shrink() _NOEXCEPT;
        -: 1454:
        -: 1455:    _LIBCPP_INLINE_VISIBILITY void __shrink_or_extend(size_type __target_capacity);
        -: 1456:
        -: 1457:    _LIBCPP_INLINE_VISIBILITY
function _ZNKSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__is_longEv called 2 returned 100% blocks executed 100%
        2: 1458:    bool __is_long() const _NOEXCEPT
        2: 1459:        {return bool(__r_.first().__s.__size_ & __short_mask);}
        2: 1459-block  0
        -: 1460:
        -: 1461:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 1462:
        -: 1463:    bool __dereferenceable(const const_iterator* __i) const;
        -: 1464:    bool __decrementable(const const_iterator* __i) const;
        -: 1465:    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;
        -: 1466:    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;
        -: 1467:
        -: 1468:#endif // _LIBCPP_DEBUG_LEVEL == 2
        -: 1469:
        -: 1470:private:
        -: 1471:    _LIBCPP_INLINE_VISIBILITY
        -: 1472:    allocator_type& __alloc() _NOEXCEPT
        -: 1473:        {return __r_.second();}
        -: 1474:    _LIBCPP_INLINE_VISIBILITY
        -: 1475:    const allocator_type& __alloc() const _NOEXCEPT
        -: 1476:        {return __r_.second();}
        -: 1477:
        -: 1478:#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
        -: 1479:
        -: 1480:    _LIBCPP_INLINE_VISIBILITY
        -: 1481:    void __set_short_size(size_type __s) _NOEXCEPT
        -: 1482:#   ifdef _LIBCPP_BIG_ENDIAN
        -: 1483:        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}
        -: 1484:#   else
        -: 1485:        {__r_.first().__s.__size_ = (unsigned char)(__s);}
        -: 1486:#   endif
        -: 1487:
        -: 1488:    _LIBCPP_INLINE_VISIBILITY
        -: 1489:    size_type __get_short_size() const _NOEXCEPT
        -: 1490:#   ifdef _LIBCPP_BIG_ENDIAN
        -: 1491:        {return __r_.first().__s.__size_ >> 1;}
        -: 1492:#   else
        -: 1493:        {return __r_.first().__s.__size_;}
        -: 1494:#   endif
        -: 1495:
        -: 1496:#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
        -: 1497:
        -: 1498:    _LIBCPP_INLINE_VISIBILITY
        -: 1499:    void __set_short_size(size_type __s) _NOEXCEPT
        -: 1500:#   ifdef _LIBCPP_BIG_ENDIAN
        -: 1501:        {__r_.first().__s.__size_ = (unsigned char)(__s);}
        -: 1502:#   else
        -: 1503:        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}
        -: 1504:#   endif
        -: 1505:
        -: 1506:    _LIBCPP_INLINE_VISIBILITY
        -: 1507:    size_type __get_short_size() const _NOEXCEPT
        -: 1508:#   ifdef _LIBCPP_BIG_ENDIAN
        -: 1509:        {return __r_.first().__s.__size_;}
        -: 1510:#   else
        -: 1511:        {return __r_.first().__s.__size_ >> 1;}
        -: 1512:#   endif
        -: 1513:
        -: 1514:#endif // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
        -: 1515:
        -: 1516:    _LIBCPP_INLINE_VISIBILITY
        -: 1517:    void __set_long_size(size_type __s) _NOEXCEPT
        -: 1518:        {__r_.first().__l.__size_ = __s;}
        -: 1519:    _LIBCPP_INLINE_VISIBILITY
        -: 1520:    size_type __get_long_size() const _NOEXCEPT
        -: 1521:        {return __r_.first().__l.__size_;}
        -: 1522:    _LIBCPP_INLINE_VISIBILITY
        -: 1523:    void __set_size(size_type __s) _NOEXCEPT
        -: 1524:        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}
        -: 1525:
        -: 1526:    _LIBCPP_INLINE_VISIBILITY
        -: 1527:    void __set_long_cap(size_type __s) _NOEXCEPT
        -: 1528:        {__r_.first().__l.__cap_  = __long_mask | __s;}
        -: 1529:    _LIBCPP_INLINE_VISIBILITY
        -: 1530:    size_type __get_long_cap() const _NOEXCEPT
        -: 1531:        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}
        -: 1532:
        -: 1533:    _LIBCPP_INLINE_VISIBILITY
        -: 1534:    void __set_long_pointer(pointer __p) _NOEXCEPT
        -: 1535:        {__r_.first().__l.__data_ = __p;}
        -: 1536:    _LIBCPP_INLINE_VISIBILITY
        -: 1537:    pointer __get_long_pointer() _NOEXCEPT
        -: 1538:        {return __r_.first().__l.__data_;}
        -: 1539:    _LIBCPP_INLINE_VISIBILITY
function _ZNKSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE18__get_long_pointerEv called 2 returned 100% blocks executed 100%
        2: 1540:    const_pointer __get_long_pointer() const _NOEXCEPT
        2: 1541:        {return __r_.first().__l.__data_;}
        2: 1541-block  0
        -: 1542:    _LIBCPP_INLINE_VISIBILITY
        -: 1543:    pointer __get_short_pointer() _NOEXCEPT
        -: 1544:        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}
        -: 1545:    _LIBCPP_INLINE_VISIBILITY
function _ZNKSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE19__get_short_pointerEv called 0 returned 0% blocks executed 0%
    #####: 1546:    const_pointer __get_short_pointer() const _NOEXCEPT
    #####: 1547:        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    $$$$$: 1547-block  0
        -: 1548:    _LIBCPP_INLINE_VISIBILITY
        -: 1549:    pointer __get_pointer() _NOEXCEPT
        -: 1550:        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
        -: 1551:    _LIBCPP_INLINE_VISIBILITY
function _ZNKSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE13__get_pointerEv called 2 returned 100% blocks executed 75%
        2: 1552:    const_pointer __get_pointer() const _NOEXCEPT
        2: 1553:        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
        2: 1553-block  0
branch  0 taken 2
branch  1 taken 0
        2: 1553-block  1
    $$$$$: 1553-block  2
        2: 1553-block  3
        -: 1554:
        -: 1555:    _LIBCPP_INLINE_VISIBILITY
function _ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__zeroEv called 1 returned 100% blocks executed 100%
        1: 1556:    void __zero() _NOEXCEPT
        -: 1557:        {
        1: 1558:            size_type (&__a)[__n_words] = __r_.first().__r.__words;
        4: 1559:            for (unsigned __i = 0; __i < __n_words; ++__i)
        1: 1559-block  0
        4: 1559-block  1
branch  0 taken 3
branch  1 taken 1
        3: 1559-block  2
        3: 1560:                __a[__i] = 0;
        3: 1560-block  0
        1: 1561:        }
        1: 1561-block  0
        -: 1562:
        -: 1563:    template <size_type __a> static
        -: 1564:        _LIBCPP_INLINE_VISIBILITY
        -: 1565:        size_type __align_it(size_type __s) _NOEXCEPT
        -: 1566:            {return (__s + (__a-1)) & ~(__a-1);}
        -: 1567:    enum {__alignment = 16};
        -: 1568:    static _LIBCPP_INLINE_VISIBILITY
        -: 1569:    size_type __recommend(size_type __s) _NOEXCEPT
        -: 1570:        {
        -: 1571:        if (__s < __min_cap) return static_cast<size_type>(__min_cap) - 1;
        -: 1572:        size_type __guess = __align_it<sizeof(value_type) < __alignment ?
        -: 1573:                     __alignment/sizeof(value_type) : 1 > (__s+1) - 1;
        -: 1574:        if (__guess == __min_cap) ++__guess;
        -: 1575:        return __guess;
        -: 1576:        }
        -: 1577:
        -: 1578:    inline
        -: 1579:    void __init(const value_type* __s, size_type __sz, size_type __reserve);
        -: 1580:    inline
        -: 1581:    void __init(const value_type* __s, size_type __sz);
        -: 1582:    inline
        -: 1583:    void __init(size_type __n, value_type __c);
        -: 1584:
        -: 1585:    // Slow path for the (inlined) copy constructor for 'long' strings.
        -: 1586:    // Always externally instantiated and not inlined.
        -: 1587:    // Requires that __s is zero terminated.
        -: 1588:    // The main reason for this function to exist is because for unstable, we
        -: 1589:    // want to allow inlining of the copy constructor. However, we don't want
        -: 1590:    // to call the __init() functions as those are marked as inline which may
        -: 1591:    // result in over-aggressive inlining by the compiler, where our aim is
        -: 1592:    // to only inline the fast path code directly in the ctor.
        -: 1593:    void __init_copy_ctor_external(const value_type* __s, size_type __sz);
        -: 1594:
        -: 1595:    template <class _InputIterator>
        -: 1596:    inline
        -: 1597:    _EnableIf
        -: 1598:    <
        -: 1599:        __is_exactly_cpp17_input_iterator<_InputIterator>::value
        -: 1600:    >
        -: 1601:    __init(_InputIterator __first, _InputIterator __last);
        -: 1602:
        -: 1603:    template <class _ForwardIterator>
        -: 1604:    inline
        -: 1605:    _EnableIf
        -: 1606:    <
        -: 1607:        __is_cpp17_forward_iterator<_ForwardIterator>::value
        -: 1608:    >
        -: 1609:    __init(_ForwardIterator __first, _ForwardIterator __last);
        -: 1610:
        -: 1611:    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
        -: 1612:                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);
        -: 1613:    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
        -: 1614:                               size_type __n_copy,  size_type __n_del,
        -: 1615:                               size_type __n_add, const value_type* __p_new_stuff);
        -: 1616:
        -: 1617:    // __assign_no_alias is invoked for assignment operations where we
        -: 1618:    // have proof that the input does not alias the current instance.
        -: 1619:    // For example, operator=(basic_string) performs a 'self' check.
        -: 1620:    template <bool __is_short>
        -: 1621:    basic_string& __assign_no_alias(const value_type* __s, size_type __n);
        -: 1622:
        -: 1623:    _LIBCPP_INLINE_VISIBILITY
        -: 1624:    void __erase_to_end(size_type __pos);
        -: 1625:
        -: 1626:    // __erase_external_with_move is invoked for erase() invocations where
        -: 1627:    // `n ~= npos`, likely requiring memory moves on the string data.
        -: 1628:    void __erase_external_with_move(size_type __pos, size_type __n);
        -: 1629:
        -: 1630:    _LIBCPP_INLINE_VISIBILITY
        -: 1631:    void __copy_assign_alloc(const basic_string& __str)
        -: 1632:        {__copy_assign_alloc(__str, integral_constant<bool,
        -: 1633:                      __alloc_traits::propagate_on_container_copy_assignment::value>());}
        -: 1634:
        -: 1635:    _LIBCPP_INLINE_VISIBILITY
        -: 1636:    void __copy_assign_alloc(const basic_string& __str, true_type)
        -: 1637:        {
        -: 1638:            if (__alloc() == __str.__alloc())
        -: 1639:                __alloc() = __str.__alloc();
        -: 1640:            else
        -: 1641:            {
        -: 1642:                if (!__str.__is_long())
        -: 1643:                {
        -: 1644:                    __clear_and_shrink();
        -: 1645:                    __alloc() = __str.__alloc();
        -: 1646:                }
        -: 1647:                else
        -: 1648:                {
        -: 1649:                    allocator_type __a = __str.__alloc();
        -: 1650:                    pointer __p = __alloc_traits::allocate(__a, __str.__get_long_cap());
        -: 1651:                    __clear_and_shrink();
        -: 1652:                    __alloc() = _VSTD::move(__a);
        -: 1653:                    __set_long_pointer(__p);
        -: 1654:                    __set_long_cap(__str.__get_long_cap());
        -: 1655:                    __set_long_size(__str.size());
        -: 1656:                }
        -: 1657:            }
        -: 1658:        }
        -: 1659:
        -: 1660:    _LIBCPP_INLINE_VISIBILITY
        -: 1661:    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT
        -: 1662:        {}
        -: 1663:
        -: 1664:#ifndef _LIBCPP_CXX03_LANG
        -: 1665:    _LIBCPP_INLINE_VISIBILITY
        -: 1666:    void __move_assign(basic_string& __str, false_type)
        -: 1667:        _NOEXCEPT_(__alloc_traits::is_always_equal::value);
        -: 1668:    _LIBCPP_INLINE_VISIBILITY
        -: 1669:    void __move_assign(basic_string& __str, true_type)
        -: 1670:#if _LIBCPP_STD_VER > 14
        -: 1671:        _NOEXCEPT;
        -: 1672:#else
        -: 1673:        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);
        -: 1674:#endif
        -: 1675:#endif
        -: 1676:
        -: 1677:    _LIBCPP_INLINE_VISIBILITY
        -: 1678:    void
        -: 1679:    __move_assign_alloc(basic_string& __str)
        -: 1680:        _NOEXCEPT_(
        -: 1681:            !__alloc_traits::propagate_on_container_move_assignment::value ||
        -: 1682:            is_nothrow_move_assignable<allocator_type>::value)
        -: 1683:    {__move_assign_alloc(__str, integral_constant<bool,
        -: 1684:                      __alloc_traits::propagate_on_container_move_assignment::value>());}
        -: 1685:
        -: 1686:    _LIBCPP_INLINE_VISIBILITY
        -: 1687:    void __move_assign_alloc(basic_string& __c, true_type)
        -: 1688:        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)
        -: 1689:        {
        -: 1690:            __alloc() = _VSTD::move(__c.__alloc());
        -: 1691:        }
        -: 1692:
        -: 1693:    _LIBCPP_INLINE_VISIBILITY
        -: 1694:    void __move_assign_alloc(basic_string&, false_type)
        -: 1695:        _NOEXCEPT
        -: 1696:        {}
        -: 1697:
        -: 1698:    basic_string& __assign_external(const value_type* __s);
        -: 1699:    basic_string& __assign_external(const value_type* __s, size_type __n);
        -: 1700:
        -: 1701:    // Assigns the value in __s, guaranteed to be __n < __min_cap in length.
        -: 1702:    inline basic_string& __assign_short(const value_type* __s, size_type __n) {
        -: 1703:      pointer __p = __is_long()
        -: 1704:                        ? (__set_long_size(__n), __get_long_pointer())
        -: 1705:                        : (__set_short_size(__n), __get_short_pointer());
        -: 1706:      traits_type::move(_VSTD::__to_address(__p), __s, __n);
        -: 1707:      traits_type::assign(__p[__n], value_type());
        -: 1708:      return *this;
        -: 1709:    }
        -: 1710:
        -: 1711:    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();
        -: 1712:    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);
        -: 1713:
        -: 1714:    template<class _Tp>
        -: 1715:    _LIBCPP_INLINE_VISIBILITY
        -: 1716:    bool __addr_in_range(_Tp&& __t) const {
        -: 1717:        const volatile void *__p = _VSTD::addressof(__t);
        -: 1718:        return data() <= __p && __p <= data() + size();
        -: 1719:    }
        -: 1720:
        -: 1721:    _LIBCPP_NORETURN _LIBCPP_HIDE_FROM_ABI
        -: 1722:    void __throw_length_error() const {
        -: 1723:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1724:        __basic_string_common<true>::__throw_length_error();
        -: 1725:#else
        -: 1726:        _VSTD::abort();
        -: 1727:#endif
        -: 1728:    }
        -: 1729:
        -: 1730:    _LIBCPP_NORETURN _LIBCPP_HIDE_FROM_ABI
        -: 1731:    void __throw_out_of_range() const {
        -: 1732:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 1733:        __basic_string_common<true>::__throw_out_of_range();
        -: 1734:#else
        -: 1735:        _VSTD::abort();
        -: 1736:#endif
        -: 1737:    }
        -: 1738:
        -: 1739:    friend basic_string operator+<>(const basic_string&, const basic_string&);
        -: 1740:    friend basic_string operator+<>(const value_type*, const basic_string&);
        -: 1741:    friend basic_string operator+<>(value_type, const basic_string&);
        -: 1742:    friend basic_string operator+<>(const basic_string&, const value_type*);
        -: 1743:    friend basic_string operator+<>(const basic_string&, value_type);
        -: 1744:};
        -: 1745:
        -: 1746:// These declarations must appear before any functions are implicitly used
        -: 1747:// so that they have the correct visibility specifier.
        -: 1748:#ifdef _LIBCPP_ABI_STRING_OPTIMIZED_EXTERNAL_INSTANTIATION
        -: 1749:    _LIBCPP_STRING_UNSTABLE_EXTERN_TEMPLATE_LIST(_LIBCPP_EXTERN_TEMPLATE, char)
        -: 1750:#   ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 1751:        _LIBCPP_STRING_UNSTABLE_EXTERN_TEMPLATE_LIST(_LIBCPP_EXTERN_TEMPLATE, wchar_t)
        -: 1752:#   endif
        -: 1753:#else
        -: 1754:    _LIBCPP_STRING_V1_EXTERN_TEMPLATE_LIST(_LIBCPP_EXTERN_TEMPLATE, char)
        -: 1755:#   ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 1756:        _LIBCPP_STRING_V1_EXTERN_TEMPLATE_LIST(_LIBCPP_EXTERN_TEMPLATE, wchar_t)
        -: 1757:#   endif
        -: 1758:#endif
        -: 1759:
        -: 1760:
        -: 1761:#ifndef _LIBCPP_HAS_NO_DEDUCTION_GUIDES
        -: 1762:template<class _InputIterator,
        -: 1763:         class _CharT = __iter_value_type<_InputIterator>,
        -: 1764:         class _Allocator = allocator<_CharT>,
        -: 1765:         class = _EnableIf<__is_cpp17_input_iterator<_InputIterator>::value>,
        -: 1766:         class = _EnableIf<__is_allocator<_Allocator>::value>
        -: 1767:         >
        -: 1768:basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())
        -: 1769:  -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;
        -: 1770:
        -: 1771:template<class _CharT,
        -: 1772:         class _Traits,
        -: 1773:         class _Allocator = allocator<_CharT>,
        -: 1774:         class = _EnableIf<__is_allocator<_Allocator>::value>
        -: 1775:         >
        -: 1776:explicit basic_string(basic_string_view<_CharT, _Traits>, const _Allocator& = _Allocator())
        -: 1777:  -> basic_string<_CharT, _Traits, _Allocator>;
        -: 1778:
        -: 1779:template<class _CharT,
        -: 1780:         class _Traits,
        -: 1781:         class _Allocator = allocator<_CharT>,
        -: 1782:         class = _EnableIf<__is_allocator<_Allocator>::value>,
        -: 1783:         class _Sz = typename allocator_traits<_Allocator>::size_type
        -: 1784:         >
        -: 1785:basic_string(basic_string_view<_CharT, _Traits>, _Sz, _Sz, const _Allocator& = _Allocator())
        -: 1786:  -> basic_string<_CharT, _Traits, _Allocator>;
        -: 1787:#endif
        -: 1788:
        -: 1789:template <class _CharT, class _Traits, class _Allocator>
        -: 1790:inline
        -: 1791:void
        -: 1792:basic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()
        -: 1793:{
        -: 1794:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 1795:    __get_db()->__invalidate_all(this);
        -: 1796:#endif
        -: 1797:}
        -: 1798:
        -: 1799:template <class _CharT, class _Traits, class _Allocator>
        -: 1800:inline
        -: 1801:void
        -: 1802:basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type __pos)
        -: 1803:{
        -: 1804:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 1805:    __c_node* __c = __get_db()->__find_c_and_lock(this);
        -: 1806:    if (__c)
        -: 1807:    {
        -: 1808:        const_pointer __new_last = __get_pointer() + __pos;
        -: 1809:        for (__i_node** __p = __c->end_; __p != __c->beg_; )
        -: 1810:        {
        -: 1811:            --__p;
        -: 1812:            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);
        -: 1813:            if (__i->base() > __new_last)
        -: 1814:            {
        -: 1815:                (*__p)->__c_ = nullptr;
        -: 1816:                if (--__c->end_ != __p)
        -: 1817:                    _VSTD::memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));
        -: 1818:            }
        -: 1819:        }
        -: 1820:        __get_db()->unlock();
        -: 1821:    }
        -: 1822:#else
        -: 1823:    (void)__pos;
        -: 1824:#endif // _LIBCPP_DEBUG_LEVEL == 2
        -: 1825:}
        -: 1826:
        -: 1827:template <class _CharT, class _Traits, class _Allocator>
        -: 1828:inline
function _ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1Ev called 1 returned 100% blocks executed 100%
function _ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC2Ev called 1 returned 100% blocks executed 66%
        2: 1829:basic_string<_CharT, _Traits, _Allocator>::basic_string()
        -: 1830:    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)
        1: 1831:     : __r_(__default_init_tag(), __default_init_tag())
        1: 1831-block  0
branch  0 taken 1
branch  1 taken 0
    $$$$$: 1831-block  1
        2: 1832:{
        -: 1833:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 1834:    __get_db()->__insert_c(this);
        -: 1835:#endif
        1: 1836:    __zero();
        2: 1837:}
        1: 1837-block  0
        1: 1837-block  1
        -: 1838:
        -: 1839:template <class _CharT, class _Traits, class _Allocator>
        -: 1840:inline
        -: 1841:basic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)
        -: 1842:#if _LIBCPP_STD_VER <= 14
        -: 1843:        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)
        -: 1844:#else
        -: 1845:        _NOEXCEPT
        -: 1846:#endif
        -: 1847:: __r_(__default_init_tag(), __a)
        -: 1848:{
        -: 1849:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 1850:    __get_db()->__insert_c(this);
        -: 1851:#endif
        -: 1852:    __zero();
        -: 1853:}
        -: 1854:
        -: 1855:template <class _CharT, class _Traits, class _Allocator>
        -: 1856:void basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,
        -: 1857:                                                       size_type __sz,
        -: 1858:                                                       size_type __reserve)
        -: 1859:{
        -: 1860:    if (__reserve > max_size())
        -: 1861:        this->__throw_length_error();
        -: 1862:    pointer __p;
        -: 1863:    if (__reserve < __min_cap)
        -: 1864:    {
        -: 1865:        __set_short_size(__sz);
        -: 1866:        __p = __get_short_pointer();
        -: 1867:    }
        -: 1868:    else
        -: 1869:    {
        -: 1870:        size_type __cap = __recommend(__reserve);
        -: 1871:        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        -: 1872:        __set_long_pointer(__p);
        -: 1873:        __set_long_cap(__cap+1);
        -: 1874:        __set_long_size(__sz);
        -: 1875:    }
        -: 1876:    traits_type::copy(_VSTD::__to_address(__p), __s, __sz);
        -: 1877:    traits_type::assign(__p[__sz], value_type());
        -: 1878:}
        -: 1879:
        -: 1880:template <class _CharT, class _Traits, class _Allocator>
        -: 1881:void
        -: 1882:basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)
        -: 1883:{
        -: 1884:    if (__sz > max_size())
        -: 1885:        this->__throw_length_error();
        -: 1886:    pointer __p;
        -: 1887:    if (__sz < __min_cap)
        -: 1888:    {
        -: 1889:        __set_short_size(__sz);
        -: 1890:        __p = __get_short_pointer();
        -: 1891:    }
        -: 1892:    else
        -: 1893:    {
        -: 1894:        size_type __cap = __recommend(__sz);
        -: 1895:        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        -: 1896:        __set_long_pointer(__p);
        -: 1897:        __set_long_cap(__cap+1);
        -: 1898:        __set_long_size(__sz);
        -: 1899:    }
        -: 1900:    traits_type::copy(_VSTD::__to_address(__p), __s, __sz);
        -: 1901:    traits_type::assign(__p[__sz], value_type());
        -: 1902:}
        -: 1903:
        -: 1904:template <class _CharT, class _Traits, class _Allocator>
        -: 1905:template <class>
        -: 1906:basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, const _Allocator& __a)
        -: 1907:    : __r_(__default_init_tag(), __a)
        -: 1908:{
        -: 1909:    _LIBCPP_ASSERT(__s != nullptr, "basic_string(const char*, allocator) detected nullptr");
        -: 1910:    __init(__s, traits_type::length(__s));
        -: 1911:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 1912:    __get_db()->__insert_c(this);
        -: 1913:#endif
        -: 1914:}
        -: 1915:
        -: 1916:template <class _CharT, class _Traits, class _Allocator>
        -: 1917:inline
        -: 1918:basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n)
        -: 1919:     : __r_(__default_init_tag(), __default_init_tag())
        -: 1920:{
        -: 1921:    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "basic_string(const char*, n) detected nullptr");
        -: 1922:    __init(__s, __n);
        -: 1923:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 1924:    __get_db()->__insert_c(this);
        -: 1925:#endif
        -: 1926:}
        -: 1927:
        -: 1928:template <class _CharT, class _Traits, class _Allocator>
        -: 1929:inline
        -: 1930:basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n, const _Allocator& __a)
        -: 1931:    : __r_(__default_init_tag(), __a)
        -: 1932:{
        -: 1933:    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "basic_string(const char*, n, allocator) detected nullptr");
        -: 1934:    __init(__s, __n);
        -: 1935:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 1936:    __get_db()->__insert_c(this);
        -: 1937:#endif
        -: 1938:}
        -: 1939:
        -: 1940:template <class _CharT, class _Traits, class _Allocator>
        -: 1941:basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)
        -: 1942:    : __r_(__default_init_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc()))
        -: 1943:{
        -: 1944:    if (!__str.__is_long())
        -: 1945:        __r_.first().__r = __str.__r_.first().__r;
        -: 1946:    else
        -: 1947:        __init_copy_ctor_external(_VSTD::__to_address(__str.__get_long_pointer()),
        -: 1948:                                  __str.__get_long_size());
        -: 1949:
        -: 1950:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 1951:    __get_db()->__insert_c(this);
        -: 1952:#endif
        -: 1953:}
        -: 1954:
        -: 1955:template <class _CharT, class _Traits, class _Allocator>
        -: 1956:basic_string<_CharT, _Traits, _Allocator>::basic_string(
        -: 1957:    const basic_string& __str, const allocator_type& __a)
        -: 1958:    : __r_(__default_init_tag(), __a)
        -: 1959:{
        -: 1960:    if (!__str.__is_long())
        -: 1961:        __r_.first().__r = __str.__r_.first().__r;
        -: 1962:    else
        -: 1963:        __init_copy_ctor_external(_VSTD::__to_address(__str.__get_long_pointer()),
        -: 1964:                                  __str.__get_long_size());
        -: 1965:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 1966:    __get_db()->__insert_c(this);
        -: 1967:#endif
        -: 1968:}
        -: 1969:
        -: 1970:template <class _CharT, class _Traits, class _Allocator>
        -: 1971:void basic_string<_CharT, _Traits, _Allocator>::__init_copy_ctor_external(
        -: 1972:    const value_type* __s, size_type __sz) {
        -: 1973:  pointer __p;
        -: 1974:  if (__sz < __min_cap) {
        -: 1975:    __p = __get_short_pointer();
        -: 1976:    __set_short_size(__sz);
        -: 1977:  } else {
        -: 1978:    if (__sz > max_size())
        -: 1979:      this->__throw_length_error();
        -: 1980:    size_t __cap = __recommend(__sz);
        -: 1981:    __p = __alloc_traits::allocate(__alloc(), __cap + 1);
        -: 1982:    __set_long_pointer(__p);
        -: 1983:    __set_long_cap(__cap + 1);
        -: 1984:    __set_long_size(__sz);
        -: 1985:  }
        -: 1986:  traits_type::copy(_VSTD::__to_address(__p), __s, __sz + 1);
        -: 1987:}
        -: 1988:
        -: 1989:#ifndef _LIBCPP_CXX03_LANG
        -: 1990:
        -: 1991:template <class _CharT, class _Traits, class _Allocator>
        -: 1992:inline
        -: 1993:basic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)
        -: 1994:#if _LIBCPP_STD_VER <= 14
        -: 1995:        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)
        -: 1996:#else
        -: 1997:        _NOEXCEPT
        -: 1998:#endif
        -: 1999:    : __r_(_VSTD::move(__str.__r_))
        -: 2000:{
        -: 2001:    __str.__zero();
        -: 2002:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2003:    __get_db()->__insert_c(this);
        -: 2004:    if (__is_long())
        -: 2005:        __get_db()->swap(this, &__str);
        -: 2006:#endif
        -: 2007:}
        -: 2008:
        -: 2009:template <class _CharT, class _Traits, class _Allocator>
        -: 2010:inline
        -: 2011:basic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)
        -: 2012:    : __r_(__default_init_tag(), __a)
        -: 2013:{
        -: 2014:    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move
        -: 2015:        __init(_VSTD::__to_address(__str.__get_long_pointer()), __str.__get_long_size());
        -: 2016:    else
        -: 2017:    {
        -: 2018:        __r_.first().__r = __str.__r_.first().__r;
        -: 2019:        __str.__zero();
        -: 2020:    }
        -: 2021:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2022:    __get_db()->__insert_c(this);
        -: 2023:    if (__is_long())
        -: 2024:        __get_db()->swap(this, &__str);
        -: 2025:#endif
        -: 2026:}
        -: 2027:
        -: 2028:#endif // _LIBCPP_CXX03_LANG
        -: 2029:
        -: 2030:template <class _CharT, class _Traits, class _Allocator>
        -: 2031:void
        -: 2032:basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)
        -: 2033:{
        -: 2034:    if (__n > max_size())
        -: 2035:        this->__throw_length_error();
        -: 2036:    pointer __p;
        -: 2037:    if (__n < __min_cap)
        -: 2038:    {
        -: 2039:        __set_short_size(__n);
        -: 2040:        __p = __get_short_pointer();
        -: 2041:    }
        -: 2042:    else
        -: 2043:    {
        -: 2044:        size_type __cap = __recommend(__n);
        -: 2045:        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        -: 2046:        __set_long_pointer(__p);
        -: 2047:        __set_long_cap(__cap+1);
        -: 2048:        __set_long_size(__n);
        -: 2049:    }
        -: 2050:    traits_type::assign(_VSTD::__to_address(__p), __n, __c);
        -: 2051:    traits_type::assign(__p[__n], value_type());
        -: 2052:}
        -: 2053:
        -: 2054:template <class _CharT, class _Traits, class _Allocator>
        -: 2055:inline
        -: 2056:basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c)
        -: 2057:     : __r_(__default_init_tag(), __default_init_tag())
        -: 2058:{
        -: 2059:    __init(__n, __c);
        -: 2060:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2061:    __get_db()->__insert_c(this);
        -: 2062:#endif
        -: 2063:}
        -: 2064:
        -: 2065:template <class _CharT, class _Traits, class _Allocator>
        -: 2066:template <class>
        -: 2067:basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c, const _Allocator& __a)
        -: 2068:    : __r_(__default_init_tag(), __a)
        -: 2069:{
        -: 2070:    __init(__n, __c);
        -: 2071:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2072:    __get_db()->__insert_c(this);
        -: 2073:#endif
        -: 2074:}
        -: 2075:
        -: 2076:template <class _CharT, class _Traits, class _Allocator>
        -: 2077:basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str,
        -: 2078:                                                        size_type __pos, size_type __n,
        -: 2079:                                                        const _Allocator& __a)
        -: 2080:    : __r_(__default_init_tag(), __a)
        -: 2081:{
        -: 2082:    size_type __str_sz = __str.size();
        -: 2083:    if (__pos > __str_sz)
        -: 2084:        this->__throw_out_of_range();
        -: 2085:    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));
        -: 2086:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2087:    __get_db()->__insert_c(this);
        -: 2088:#endif
        -: 2089:}
        -: 2090:
        -: 2091:template <class _CharT, class _Traits, class _Allocator>
        -: 2092:inline
        -: 2093:basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,
        -: 2094:                                                        const _Allocator& __a)
        -: 2095:    : __r_(__default_init_tag(), __a)
        -: 2096:{
        -: 2097:    size_type __str_sz = __str.size();
        -: 2098:    if (__pos > __str_sz)
        -: 2099:        this->__throw_out_of_range();
        -: 2100:    __init(__str.data() + __pos, __str_sz - __pos);
        -: 2101:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2102:    __get_db()->__insert_c(this);
        -: 2103:#endif
        -: 2104:}
        -: 2105:
        -: 2106:template <class _CharT, class _Traits, class _Allocator>
        -: 2107:template <class _Tp, class>
        -: 2108:basic_string<_CharT, _Traits, _Allocator>::basic_string(
        -: 2109:             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a)
        -: 2110:    : __r_(__default_init_tag(), __a)
        -: 2111:{
        -: 2112:    __self_view __sv0 = __t;
        -: 2113:    __self_view __sv = __sv0.substr(__pos, __n);
        -: 2114:    __init(__sv.data(), __sv.size());
        -: 2115:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2116:    __get_db()->__insert_c(this);
        -: 2117:#endif
        -: 2118:}
        -: 2119:
        -: 2120:template <class _CharT, class _Traits, class _Allocator>
        -: 2121:template <class _Tp, class>
        -: 2122:basic_string<_CharT, _Traits, _Allocator>::basic_string(const _Tp & __t)
        -: 2123:     : __r_(__default_init_tag(), __default_init_tag())
        -: 2124:{
        -: 2125:    __self_view __sv = __t;
        -: 2126:    __init(__sv.data(), __sv.size());
        -: 2127:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2128:    __get_db()->__insert_c(this);
        -: 2129:#endif
        -: 2130:}
        -: 2131:
        -: 2132:template <class _CharT, class _Traits, class _Allocator>
        -: 2133:template <class _Tp, class>
        -: 2134:basic_string<_CharT, _Traits, _Allocator>::basic_string(const _Tp & __t, const _Allocator& __a)
        -: 2135:    : __r_(__default_init_tag(), __a)
        -: 2136:{
        -: 2137:    __self_view __sv = __t;
        -: 2138:    __init(__sv.data(), __sv.size());
        -: 2139:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2140:    __get_db()->__insert_c(this);
        -: 2141:#endif
        -: 2142:}
        -: 2143:
        -: 2144:template <class _CharT, class _Traits, class _Allocator>
        -: 2145:template <class _InputIterator>
        -: 2146:_EnableIf
        -: 2147:<
        -: 2148:    __is_exactly_cpp17_input_iterator<_InputIterator>::value
        -: 2149:>
        -: 2150:basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)
        -: 2151:{
        -: 2152:    __zero();
        -: 2153:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 2154:    try
        -: 2155:    {
        -: 2156:#endif // _LIBCPP_NO_EXCEPTIONS
        -: 2157:    for (; __first != __last; ++__first)
        -: 2158:        push_back(*__first);
        -: 2159:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 2160:    }
        -: 2161:    catch (...)
        -: 2162:    {
        -: 2163:        if (__is_long())
        -: 2164:            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
        -: 2165:        throw;
        -: 2166:    }
        -: 2167:#endif // _LIBCPP_NO_EXCEPTIONS
        -: 2168:}
        -: 2169:
        -: 2170:template <class _CharT, class _Traits, class _Allocator>
        -: 2171:template <class _ForwardIterator>
        -: 2172:_EnableIf
        -: 2173:<
        -: 2174:    __is_cpp17_forward_iterator<_ForwardIterator>::value
        -: 2175:>
        -: 2176:basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)
        -: 2177:{
        -: 2178:    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));
        -: 2179:    if (__sz > max_size())
        -: 2180:        this->__throw_length_error();
        -: 2181:    pointer __p;
        -: 2182:    if (__sz < __min_cap)
        -: 2183:    {
        -: 2184:        __set_short_size(__sz);
        -: 2185:        __p = __get_short_pointer();
        -: 2186:    }
        -: 2187:    else
        -: 2188:    {
        -: 2189:        size_type __cap = __recommend(__sz);
        -: 2190:        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        -: 2191:        __set_long_pointer(__p);
        -: 2192:        __set_long_cap(__cap+1);
        -: 2193:        __set_long_size(__sz);
        -: 2194:    }
        -: 2195:
        -: 2196:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 2197:    try
        -: 2198:    {
        -: 2199:#endif  // _LIBCPP_NO_EXCEPTIONS
        -: 2200:    for (; __first != __last; ++__first, (void) ++__p)
        -: 2201:        traits_type::assign(*__p, *__first);
        -: 2202:    traits_type::assign(*__p, value_type());
        -: 2203:#ifndef _LIBCPP_NO_EXCEPTIONS
        -: 2204:    }
        -: 2205:    catch (...)
        -: 2206:    {
        -: 2207:        if (__is_long())
        -: 2208:            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
        -: 2209:        throw;
        -: 2210:    }
        -: 2211:#endif  // _LIBCPP_NO_EXCEPTIONS
        -: 2212:}
        -: 2213:
        -: 2214:template <class _CharT, class _Traits, class _Allocator>
        -: 2215:template<class _InputIterator, class>
        -: 2216:inline
        -: 2217:basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)
        -: 2218:     : __r_(__default_init_tag(), __default_init_tag())
        -: 2219:{
        -: 2220:    __init(__first, __last);
        -: 2221:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2222:    __get_db()->__insert_c(this);
        -: 2223:#endif
        -: 2224:}
        -: 2225:
        -: 2226:template <class _CharT, class _Traits, class _Allocator>
        -: 2227:template<class _InputIterator, class>
        -: 2228:inline
        -: 2229:basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,
        -: 2230:                                                        const allocator_type& __a)
        -: 2231:    : __r_(__default_init_tag(), __a)
        -: 2232:{
        -: 2233:    __init(__first, __last);
        -: 2234:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2235:    __get_db()->__insert_c(this);
        -: 2236:#endif
        -: 2237:}
        -: 2238:
        -: 2239:#ifndef _LIBCPP_CXX03_LANG
        -: 2240:
        -: 2241:template <class _CharT, class _Traits, class _Allocator>
        -: 2242:inline
        -: 2243:basic_string<_CharT, _Traits, _Allocator>::basic_string(
        -: 2244:    initializer_list<_CharT> __il)
        -: 2245:     : __r_(__default_init_tag(), __default_init_tag())
        -: 2246:{
        -: 2247:    __init(__il.begin(), __il.end());
        -: 2248:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2249:    __get_db()->__insert_c(this);
        -: 2250:#endif
        -: 2251:}
        -: 2252:
        -: 2253:template <class _CharT, class _Traits, class _Allocator>
        -: 2254:inline
        -: 2255:
        -: 2256:basic_string<_CharT, _Traits, _Allocator>::basic_string(
        -: 2257:    initializer_list<_CharT> __il, const _Allocator& __a)
        -: 2258:    : __r_(__default_init_tag(), __a)
        -: 2259:{
        -: 2260:    __init(__il.begin(), __il.end());
        -: 2261:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2262:    __get_db()->__insert_c(this);
        -: 2263:#endif
        -: 2264:}
        -: 2265:
        -: 2266:#endif // _LIBCPP_CXX03_LANG
        -: 2267:
        -: 2268:template <class _CharT, class _Traits, class _Allocator>
        -: 2269:basic_string<_CharT, _Traits, _Allocator>::~basic_string()
        -: 2270:{
        -: 2271:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2272:    __get_db()->__erase_c(this);
        -: 2273:#endif
        -: 2274:    if (__is_long())
        -: 2275:        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
        -: 2276:}
        -: 2277:
        -: 2278:template <class _CharT, class _Traits, class _Allocator>
        -: 2279:void
        -: 2280:basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace
        -: 2281:    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,
        -: 2282:     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)
        -: 2283:{
        -: 2284:    size_type __ms = max_size();
        -: 2285:    if (__delta_cap > __ms - __old_cap - 1)
        -: 2286:        this->__throw_length_error();
        -: 2287:    pointer __old_p = __get_pointer();
        -: 2288:    size_type __cap = __old_cap < __ms / 2 - __alignment ?
        -: 2289:                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :
        -: 2290:                          __ms - 1;
        -: 2291:    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
        -: 2292:    __invalidate_all_iterators();
        -: 2293:    if (__n_copy != 0)
        -: 2294:        traits_type::copy(_VSTD::__to_address(__p),
        -: 2295:                          _VSTD::__to_address(__old_p), __n_copy);
        -: 2296:    if (__n_add != 0)
        -: 2297:        traits_type::copy(_VSTD::__to_address(__p) + __n_copy, __p_new_stuff, __n_add);
        -: 2298:    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
        -: 2299:    if (__sec_cp_sz != 0)
        -: 2300:        traits_type::copy(_VSTD::__to_address(__p) + __n_copy + __n_add,
        -: 2301:                          _VSTD::__to_address(__old_p) + __n_copy + __n_del, __sec_cp_sz);
        -: 2302:    if (__old_cap+1 != __min_cap)
        -: 2303:        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
        -: 2304:    __set_long_pointer(__p);
        -: 2305:    __set_long_cap(__cap+1);
        -: 2306:    __old_sz = __n_copy + __n_add + __sec_cp_sz;
        -: 2307:    __set_long_size(__old_sz);
        -: 2308:    traits_type::assign(__p[__old_sz], value_type());
        -: 2309:}
        -: 2310:
        -: 2311:template <class _CharT, class _Traits, class _Allocator>
        -: 2312:void
        -: 2313:basic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
        -: 2314:                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)
        -: 2315:{
        -: 2316:    size_type __ms = max_size();
        -: 2317:    if (__delta_cap > __ms - __old_cap)
        -: 2318:        this->__throw_length_error();
        -: 2319:    pointer __old_p = __get_pointer();
        -: 2320:    size_type __cap = __old_cap < __ms / 2 - __alignment ?
        -: 2321:                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :
        -: 2322:                          __ms - 1;
        -: 2323:    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
        -: 2324:    __invalidate_all_iterators();
        -: 2325:    if (__n_copy != 0)
        -: 2326:        traits_type::copy(_VSTD::__to_address(__p),
        -: 2327:                          _VSTD::__to_address(__old_p), __n_copy);
        -: 2328:    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
        -: 2329:    if (__sec_cp_sz != 0)
        -: 2330:        traits_type::copy(_VSTD::__to_address(__p) + __n_copy + __n_add,
        -: 2331:                          _VSTD::__to_address(__old_p) + __n_copy + __n_del,
        -: 2332:                          __sec_cp_sz);
        -: 2333:    if (__old_cap+1 != __min_cap)
        -: 2334:        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
        -: 2335:    __set_long_pointer(__p);
        -: 2336:    __set_long_cap(__cap+1);
        -: 2337:}
        -: 2338:
        -: 2339:// assign
        -: 2340:
        -: 2341:template <class _CharT, class _Traits, class _Allocator>
        -: 2342:template <bool __is_short>
        -: 2343:basic_string<_CharT, _Traits, _Allocator>&
        -: 2344:basic_string<_CharT, _Traits, _Allocator>::__assign_no_alias(
        -: 2345:    const value_type* __s, size_type __n) {
        -: 2346:  size_type __cap = __is_short ? __min_cap : __get_long_cap();
        -: 2347:  if (__n < __cap) {
        -: 2348:    pointer __p = __is_short ? __get_short_pointer() : __get_long_pointer();
        -: 2349:    __is_short ? __set_short_size(__n) : __set_long_size(__n);
        -: 2350:    traits_type::copy(_VSTD::__to_address(__p), __s, __n);
        -: 2351:    traits_type::assign(__p[__n], value_type());
        -: 2352:    __invalidate_iterators_past(__n);
        -: 2353:  } else {
        -: 2354:    size_type __sz = __is_short ? __get_short_size() : __get_long_size();
        -: 2355:    __grow_by_and_replace(__cap - 1, __n - __cap + 1, __sz, 0, __sz, __n, __s);
        -: 2356:  }
        -: 2357:  return *this;
        -: 2358:}
        -: 2359:
        -: 2360:template <class _CharT, class _Traits, class _Allocator>
        -: 2361:basic_string<_CharT, _Traits, _Allocator>&
        -: 2362:basic_string<_CharT, _Traits, _Allocator>::__assign_external(
        -: 2363:    const value_type* __s, size_type __n) {
        -: 2364:  size_type __cap = capacity();
        -: 2365:  if (__cap >= __n) {
        -: 2366:    value_type* __p = _VSTD::__to_address(__get_pointer());
        -: 2367:    traits_type::move(__p, __s, __n);
        -: 2368:    traits_type::assign(__p[__n], value_type());
        -: 2369:    __set_size(__n);
        -: 2370:    __invalidate_iterators_past(__n);
        -: 2371:  } else {
        -: 2372:    size_type __sz = size();
        -: 2373:    __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
        -: 2374:  }
        -: 2375:  return *this;
        -: 2376:}
        -: 2377:
        -: 2378:template <class _CharT, class _Traits, class _Allocator>
        -: 2379:basic_string<_CharT, _Traits, _Allocator>&
        -: 2380:basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)
        -: 2381:{
        -: 2382:    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::assign received nullptr");
        -: 2383:    return (_LIBCPP_BUILTIN_CONSTANT_P(__n) && __n < __min_cap)
        -: 2384:               ? __assign_short(__s, __n)
        -: 2385:               : __assign_external(__s, __n);
        -: 2386:}
        -: 2387:
        -: 2388:template <class _CharT, class _Traits, class _Allocator>
        -: 2389:basic_string<_CharT, _Traits, _Allocator>&
        -: 2390:basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)
        -: 2391:{
        -: 2392:    size_type __cap = capacity();
        -: 2393:    if (__cap < __n)
        -: 2394:    {
        -: 2395:        size_type __sz = size();
        -: 2396:        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
        -: 2397:    }
        -: 2398:    value_type* __p = _VSTD::__to_address(__get_pointer());
        -: 2399:    traits_type::assign(__p, __n, __c);
        -: 2400:    traits_type::assign(__p[__n], value_type());
        -: 2401:    __set_size(__n);
        -: 2402:    __invalidate_iterators_past(__n);
        -: 2403:    return *this;
        -: 2404:}
        -: 2405:
        -: 2406:template <class _CharT, class _Traits, class _Allocator>
        -: 2407:basic_string<_CharT, _Traits, _Allocator>&
        -: 2408:basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)
        -: 2409:{
        -: 2410:    pointer __p;
        -: 2411:    if (__is_long())
        -: 2412:    {
        -: 2413:        __p = __get_long_pointer();
        -: 2414:        __set_long_size(1);
        -: 2415:    }
        -: 2416:    else
        -: 2417:    {
        -: 2418:        __p = __get_short_pointer();
        -: 2419:        __set_short_size(1);
        -: 2420:    }
        -: 2421:    traits_type::assign(*__p, __c);
        -: 2422:    traits_type::assign(*++__p, value_type());
        -: 2423:    __invalidate_iterators_past(1);
        -: 2424:    return *this;
        -: 2425:}
        -: 2426:
        -: 2427:template <class _CharT, class _Traits, class _Allocator>
        -: 2428:basic_string<_CharT, _Traits, _Allocator>&
        -: 2429:basic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)
        -: 2430:{
        -: 2431:  if (this != &__str) {
        -: 2432:    __copy_assign_alloc(__str);
        -: 2433:    if (!__is_long()) {
        -: 2434:      if (!__str.__is_long()) {
        -: 2435:        __r_.first().__r = __str.__r_.first().__r;
        -: 2436:      } else {
        -: 2437:        return __assign_no_alias<true>(__str.data(), __str.size());
        -: 2438:      }
        -: 2439:    } else {
        -: 2440:      return __assign_no_alias<false>(__str.data(), __str.size());
        -: 2441:    }
        -: 2442:  }
        -: 2443:  return *this;
        -: 2444:}
        -: 2445:
        -: 2446:#ifndef _LIBCPP_CXX03_LANG
        -: 2447:
        -: 2448:template <class _CharT, class _Traits, class _Allocator>
        -: 2449:inline
        -: 2450:void
        -: 2451:basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)
        -: 2452:    _NOEXCEPT_(__alloc_traits::is_always_equal::value)
        -: 2453:{
        -: 2454:    if (__alloc() != __str.__alloc())
        -: 2455:        assign(__str);
        -: 2456:    else
        -: 2457:        __move_assign(__str, true_type());
        -: 2458:}
        -: 2459:
        -: 2460:template <class _CharT, class _Traits, class _Allocator>
        -: 2461:inline
        -: 2462:void
        -: 2463:basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)
        -: 2464:#if _LIBCPP_STD_VER > 14
        -: 2465:    _NOEXCEPT
        -: 2466:#else
        -: 2467:    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)
        -: 2468:#endif
        -: 2469:{
        -: 2470:  if (__is_long()) {
        -: 2471:    __alloc_traits::deallocate(__alloc(), __get_long_pointer(),
        -: 2472:                               __get_long_cap());
        -: 2473:#if _LIBCPP_STD_VER <= 14
        -: 2474:    if (!is_nothrow_move_assignable<allocator_type>::value) {
        -: 2475:      __set_short_size(0);
        -: 2476:      traits_type::assign(__get_short_pointer()[0], value_type());
        -: 2477:    }
        -: 2478:#endif
        -: 2479:  }
        -: 2480:  __move_assign_alloc(__str);
        -: 2481:  __r_.first() = __str.__r_.first();
        -: 2482:  __str.__set_short_size(0);
        -: 2483:  traits_type::assign(__str.__get_short_pointer()[0], value_type());
        -: 2484:}
        -: 2485:
        -: 2486:template <class _CharT, class _Traits, class _Allocator>
        -: 2487:inline
        -: 2488:basic_string<_CharT, _Traits, _Allocator>&
        -: 2489:basic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)
        -: 2490:    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
        -: 2491:{
        -: 2492:    __move_assign(__str, integral_constant<bool,
        -: 2493:          __alloc_traits::propagate_on_container_move_assignment::value>());
        -: 2494:    return *this;
        -: 2495:}
        -: 2496:
        -: 2497:#endif
        -: 2498:
        -: 2499:template <class _CharT, class _Traits, class _Allocator>
        -: 2500:template<class _InputIterator>
        -: 2501:_EnableIf
        -: 2502:<
        -: 2503:     __is_exactly_cpp17_input_iterator<_InputIterator>::value,
        -: 2504:    basic_string<_CharT, _Traits, _Allocator>&
        -: 2505:>
        -: 2506:basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
        -: 2507:{
        -: 2508:    const basic_string __temp(__first, __last, __alloc());
        -: 2509:    assign(__temp.data(), __temp.size());
        -: 2510:    return *this;
        -: 2511:}
        -: 2512:
        -: 2513:template <class _CharT, class _Traits, class _Allocator>
        -: 2514:template<class _ForwardIterator>
        -: 2515:_EnableIf
        -: 2516:<
        -: 2517:    __is_cpp17_forward_iterator<_ForwardIterator>::value,
        -: 2518:    basic_string<_CharT, _Traits, _Allocator>&
        -: 2519:>
        -: 2520:basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
        -: 2521:{
        -: 2522:    size_type __cap = capacity();
        -: 2523:    size_type __n = __string_is_trivial_iterator<_ForwardIterator>::value ?
        -: 2524:        static_cast<size_type>(_VSTD::distance(__first, __last)) : 0;
        -: 2525:
        -: 2526:    if (__string_is_trivial_iterator<_ForwardIterator>::value &&
        -: 2527:        (__cap >= __n || !__addr_in_range(*__first)))
        -: 2528:    {
        -: 2529:        if (__cap < __n)
        -: 2530:        {
        -: 2531:            size_type __sz = size();
        -: 2532:            __grow_by(__cap, __n - __cap, __sz, 0, __sz);
        -: 2533:        }
        -: 2534:        pointer __p = __get_pointer();
        -: 2535:        for (; __first != __last; ++__first, ++__p)
        -: 2536:            traits_type::assign(*__p, *__first);
        -: 2537:        traits_type::assign(*__p, value_type());
        -: 2538:        __set_size(__n);
        -: 2539:        __invalidate_iterators_past(__n);
        -: 2540:    }
        -: 2541:    else
        -: 2542:    {
        -: 2543:        const basic_string __temp(__first, __last, __alloc());
        -: 2544:        assign(__temp.data(), __temp.size());
        -: 2545:    }
        -: 2546:    return *this;
        -: 2547:}
        -: 2548:
        -: 2549:template <class _CharT, class _Traits, class _Allocator>
        -: 2550:basic_string<_CharT, _Traits, _Allocator>&
        -: 2551:basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)
        -: 2552:{
        -: 2553:    size_type __sz = __str.size();
        -: 2554:    if (__pos > __sz)
        -: 2555:        this->__throw_out_of_range();
        -: 2556:    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));
        -: 2557:}
        -: 2558:
        -: 2559:template <class _CharT, class _Traits, class _Allocator>
        -: 2560:template <class _Tp>
        -: 2561:_EnableIf
        -: 2562:<
        -: 2563:    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
        -: 2564:    && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
        -: 2565:    basic_string<_CharT, _Traits, _Allocator>&
        -: 2566:>
        -: 2567:basic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)
        -: 2568:{
        -: 2569:    __self_view __sv = __t;
        -: 2570:    size_type __sz = __sv.size();
        -: 2571:    if (__pos > __sz)
        -: 2572:        this->__throw_out_of_range();
        -: 2573:    return assign(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));
        -: 2574:}
        -: 2575:
        -: 2576:
        -: 2577:template <class _CharT, class _Traits, class _Allocator>
        -: 2578:basic_string<_CharT, _Traits, _Allocator>&
        -: 2579:basic_string<_CharT, _Traits, _Allocator>::__assign_external(const value_type* __s) {
        -: 2580:  return __assign_external(__s, traits_type::length(__s));
        -: 2581:}
        -: 2582:
        -: 2583:template <class _CharT, class _Traits, class _Allocator>
        -: 2584:basic_string<_CharT, _Traits, _Allocator>&
        -: 2585:basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)
        -: 2586:{
        -: 2587:    _LIBCPP_ASSERT(__s != nullptr, "string::assign received nullptr");
        -: 2588:    return _LIBCPP_BUILTIN_CONSTANT_P(*__s)
        -: 2589:               ? (traits_type::length(__s) < __min_cap
        -: 2590:                      ? __assign_short(__s, traits_type::length(__s))
        -: 2591:                      : __assign_external(__s, traits_type::length(__s)))
        -: 2592:               : __assign_external(__s);
        -: 2593:}
        -: 2594:// append
        -: 2595:
        -: 2596:template <class _CharT, class _Traits, class _Allocator>
        -: 2597:basic_string<_CharT, _Traits, _Allocator>&
        -: 2598:basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)
        -: 2599:{
        -: 2600:    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::append received nullptr");
        -: 2601:    size_type __cap = capacity();
        -: 2602:    size_type __sz = size();
        -: 2603:    if (__cap - __sz >= __n)
        -: 2604:    {
        -: 2605:        if (__n)
        -: 2606:        {
        -: 2607:            value_type* __p = _VSTD::__to_address(__get_pointer());
        -: 2608:            traits_type::copy(__p + __sz, __s, __n);
        -: 2609:            __sz += __n;
        -: 2610:            __set_size(__sz);
        -: 2611:            traits_type::assign(__p[__sz], value_type());
        -: 2612:        }
        -: 2613:    }
        -: 2614:    else
        -: 2615:        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
        -: 2616:    return *this;
        -: 2617:}
        -: 2618:
        -: 2619:template <class _CharT, class _Traits, class _Allocator>
        -: 2620:basic_string<_CharT, _Traits, _Allocator>&
        -: 2621:basic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)
        -: 2622:{
        -: 2623:    if (__n)
        -: 2624:    {
        -: 2625:        size_type __cap = capacity();
        -: 2626:        size_type __sz = size();
        -: 2627:        if (__cap - __sz < __n)
        -: 2628:            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        -: 2629:        pointer __p = __get_pointer();
        -: 2630:        traits_type::assign(_VSTD::__to_address(__p) + __sz, __n, __c);
        -: 2631:        __sz += __n;
        -: 2632:        __set_size(__sz);
        -: 2633:        traits_type::assign(__p[__sz], value_type());
        -: 2634:    }
        -: 2635:    return *this;
        -: 2636:}
        -: 2637:
        -: 2638:template <class _CharT, class _Traits, class _Allocator>
        -: 2639:inline void
        -: 2640:basic_string<_CharT, _Traits, _Allocator>::__append_default_init(size_type __n)
        -: 2641:{
        -: 2642:    if (__n)
        -: 2643:    {
        -: 2644:        size_type __cap = capacity();
        -: 2645:        size_type __sz = size();
        -: 2646:        if (__cap - __sz < __n)
        -: 2647:            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        -: 2648:        pointer __p = __get_pointer();
        -: 2649:        __sz += __n;
        -: 2650:        __set_size(__sz);
        -: 2651:        traits_type::assign(__p[__sz], value_type());
        -: 2652:    }
        -: 2653:}
        -: 2654:
        -: 2655:template <class _CharT, class _Traits, class _Allocator>
        -: 2656:void
        -: 2657:basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)
        -: 2658:{
        -: 2659:    bool __is_short = !__is_long();
        -: 2660:    size_type __cap;
        -: 2661:    size_type __sz;
        -: 2662:    if (__is_short)
        -: 2663:    {
        -: 2664:        __cap = __min_cap - 1;
        -: 2665:        __sz = __get_short_size();
        -: 2666:    }
        -: 2667:    else
        -: 2668:    {
        -: 2669:        __cap = __get_long_cap() - 1;
        -: 2670:        __sz = __get_long_size();
        -: 2671:    }
        -: 2672:    if (__sz == __cap)
        -: 2673:    {
        -: 2674:        __grow_by(__cap, 1, __sz, __sz, 0);
        -: 2675:        __is_short = !__is_long();
        -: 2676:    }
        -: 2677:    pointer __p;
        -: 2678:    if (__is_short)
        -: 2679:    {
        -: 2680:        __p = __get_short_pointer() + __sz;
        -: 2681:        __set_short_size(__sz+1);
        -: 2682:    }
        -: 2683:    else
        -: 2684:    {
        -: 2685:        __p = __get_long_pointer() + __sz;
        -: 2686:        __set_long_size(__sz+1);
        -: 2687:    }
        -: 2688:    traits_type::assign(*__p, __c);
        -: 2689:    traits_type::assign(*++__p, value_type());
        -: 2690:}
        -: 2691:
        -: 2692:template <class _CharT, class _Traits, class _Allocator>
        -: 2693:template<class _ForwardIterator>
        -: 2694:_EnableIf
        -: 2695:<
        -: 2696:    __is_cpp17_forward_iterator<_ForwardIterator>::value,
        -: 2697:    basic_string<_CharT, _Traits, _Allocator>&
        -: 2698:>
        -: 2699:basic_string<_CharT, _Traits, _Allocator>::append(
        -: 2700:    _ForwardIterator __first, _ForwardIterator __last)
        -: 2701:{
        -: 2702:    size_type __sz = size();
        -: 2703:    size_type __cap = capacity();
        -: 2704:    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));
        -: 2705:    if (__n)
        -: 2706:    {
        -: 2707:        if (__string_is_trivial_iterator<_ForwardIterator>::value &&
        -: 2708:            !__addr_in_range(*__first))
        -: 2709:        {
        -: 2710:            if (__cap - __sz < __n)
        -: 2711:                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        -: 2712:            pointer __p = __get_pointer() + __sz;
        -: 2713:            for (; __first != __last; ++__p, ++__first)
        -: 2714:                traits_type::assign(*__p, *__first);
        -: 2715:            traits_type::assign(*__p, value_type());
        -: 2716:            __set_size(__sz + __n);
        -: 2717:        }
        -: 2718:        else
        -: 2719:        {
        -: 2720:            const basic_string __temp(__first, __last, __alloc());
        -: 2721:            append(__temp.data(), __temp.size());
        -: 2722:        }
        -: 2723:    }
        -: 2724:    return *this;
        -: 2725:}
        -: 2726:
        -: 2727:template <class _CharT, class _Traits, class _Allocator>
        -: 2728:inline
        -: 2729:basic_string<_CharT, _Traits, _Allocator>&
        -: 2730:basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)
        -: 2731:{
        -: 2732:    return append(__str.data(), __str.size());
        -: 2733:}
        -: 2734:
        -: 2735:template <class _CharT, class _Traits, class _Allocator>
        -: 2736:basic_string<_CharT, _Traits, _Allocator>&
        -: 2737:basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)
        -: 2738:{
        -: 2739:    size_type __sz = __str.size();
        -: 2740:    if (__pos > __sz)
        -: 2741:        this->__throw_out_of_range();
        -: 2742:    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));
        -: 2743:}
        -: 2744:
        -: 2745:template <class _CharT, class _Traits, class _Allocator>
        -: 2746:template <class _Tp>
        -: 2747:    _EnableIf
        -: 2748:    <
        -: 2749:        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value  && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
        -: 2750:        basic_string<_CharT, _Traits, _Allocator>&
        -: 2751:    >
        -: 2752:basic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)
        -: 2753:{
        -: 2754:    __self_view __sv = __t;
        -: 2755:    size_type __sz = __sv.size();
        -: 2756:    if (__pos > __sz)
        -: 2757:        this->__throw_out_of_range();
        -: 2758:    return append(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));
        -: 2759:}
        -: 2760:
        -: 2761:template <class _CharT, class _Traits, class _Allocator>
        -: 2762:basic_string<_CharT, _Traits, _Allocator>&
        -: 2763:basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)
        -: 2764:{
        -: 2765:    _LIBCPP_ASSERT(__s != nullptr, "string::append received nullptr");
        -: 2766:    return append(__s, traits_type::length(__s));
        -: 2767:}
        -: 2768:
        -: 2769:// insert
        -: 2770:
        -: 2771:template <class _CharT, class _Traits, class _Allocator>
        -: 2772:basic_string<_CharT, _Traits, _Allocator>&
        -: 2773:basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)
        -: 2774:{
        -: 2775:    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::insert received nullptr");
        -: 2776:    size_type __sz = size();
        -: 2777:    if (__pos > __sz)
        -: 2778:        this->__throw_out_of_range();
        -: 2779:    size_type __cap = capacity();
        -: 2780:    if (__cap - __sz >= __n)
        -: 2781:    {
        -: 2782:        if (__n)
        -: 2783:        {
        -: 2784:            value_type* __p = _VSTD::__to_address(__get_pointer());
        -: 2785:            size_type __n_move = __sz - __pos;
        -: 2786:            if (__n_move != 0)
        -: 2787:            {
        -: 2788:                if (__p + __pos <= __s && __s < __p + __sz)
        -: 2789:                    __s += __n;
        -: 2790:                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
        -: 2791:            }
        -: 2792:            traits_type::move(__p + __pos, __s, __n);
        -: 2793:            __sz += __n;
        -: 2794:            __set_size(__sz);
        -: 2795:            traits_type::assign(__p[__sz], value_type());
        -: 2796:        }
        -: 2797:    }
        -: 2798:    else
        -: 2799:        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
        -: 2800:    return *this;
        -: 2801:}
        -: 2802:
        -: 2803:template <class _CharT, class _Traits, class _Allocator>
        -: 2804:basic_string<_CharT, _Traits, _Allocator>&
        -: 2805:basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)
        -: 2806:{
        -: 2807:    size_type __sz = size();
        -: 2808:    if (__pos > __sz)
        -: 2809:        this->__throw_out_of_range();
        -: 2810:    if (__n)
        -: 2811:    {
        -: 2812:        size_type __cap = capacity();
        -: 2813:        value_type* __p;
        -: 2814:        if (__cap - __sz >= __n)
        -: 2815:        {
        -: 2816:            __p = _VSTD::__to_address(__get_pointer());
        -: 2817:            size_type __n_move = __sz - __pos;
        -: 2818:            if (__n_move != 0)
        -: 2819:                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
        -: 2820:        }
        -: 2821:        else
        -: 2822:        {
        -: 2823:            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
        -: 2824:            __p = _VSTD::__to_address(__get_long_pointer());
        -: 2825:        }
        -: 2826:        traits_type::assign(__p + __pos, __n, __c);
        -: 2827:        __sz += __n;
        -: 2828:        __set_size(__sz);
        -: 2829:        traits_type::assign(__p[__sz], value_type());
        -: 2830:    }
        -: 2831:    return *this;
        -: 2832:}
        -: 2833:
        -: 2834:template <class _CharT, class _Traits, class _Allocator>
        -: 2835:template<class _InputIterator>
        -: 2836:_EnableIf
        -: 2837:<
        -: 2838:   __is_exactly_cpp17_input_iterator<_InputIterator>::value,
        -: 2839:   typename basic_string<_CharT, _Traits, _Allocator>::iterator
        -: 2840:>
        -: 2841:basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)
        -: 2842:{
        -: 2843:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2844:    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,
        -: 2845:        "string::insert(iterator, range) called with an iterator not"
        -: 2846:        " referring to this string");
        -: 2847:#endif
        -: 2848:    const basic_string __temp(__first, __last, __alloc());
        -: 2849:    return insert(__pos, __temp.data(), __temp.data() + __temp.size());
        -: 2850:}
        -: 2851:
        -: 2852:template <class _CharT, class _Traits, class _Allocator>
        -: 2853:template<class _ForwardIterator>
        -: 2854:_EnableIf
        -: 2855:<
        -: 2856:    __is_cpp17_forward_iterator<_ForwardIterator>::value,
        -: 2857:    typename basic_string<_CharT, _Traits, _Allocator>::iterator
        -: 2858:>
        -: 2859:basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)
        -: 2860:{
        -: 2861:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2862:    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,
        -: 2863:        "string::insert(iterator, range) called with an iterator not"
        -: 2864:        " referring to this string");
        -: 2865:#endif
        -: 2866:    size_type __ip = static_cast<size_type>(__pos - begin());
        -: 2867:    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));
        -: 2868:    if (__n)
        -: 2869:    {
        -: 2870:        if (__string_is_trivial_iterator<_ForwardIterator>::value &&
        -: 2871:            !__addr_in_range(*__first))
        -: 2872:        {
        -: 2873:            size_type __sz = size();
        -: 2874:            size_type __cap = capacity();
        -: 2875:            value_type* __p;
        -: 2876:            if (__cap - __sz >= __n)
        -: 2877:            {
        -: 2878:                __p = _VSTD::__to_address(__get_pointer());
        -: 2879:                size_type __n_move = __sz - __ip;
        -: 2880:                if (__n_move != 0)
        -: 2881:                    traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
        -: 2882:            }
        -: 2883:            else
        -: 2884:            {
        -: 2885:                __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
        -: 2886:                __p = _VSTD::__to_address(__get_long_pointer());
        -: 2887:            }
        -: 2888:            __sz += __n;
        -: 2889:            __set_size(__sz);
        -: 2890:            traits_type::assign(__p[__sz], value_type());
        -: 2891:            for (__p += __ip; __first != __last; ++__p, ++__first)
        -: 2892:                traits_type::assign(*__p, *__first);
        -: 2893:        }
        -: 2894:        else
        -: 2895:        {
        -: 2896:            const basic_string __temp(__first, __last, __alloc());
        -: 2897:            return insert(__pos, __temp.data(), __temp.data() + __temp.size());
        -: 2898:        }
        -: 2899:    }
        -: 2900:    return begin() + __ip;
        -: 2901:}
        -: 2902:
        -: 2903:template <class _CharT, class _Traits, class _Allocator>
        -: 2904:inline
        -: 2905:basic_string<_CharT, _Traits, _Allocator>&
        -: 2906:basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)
        -: 2907:{
        -: 2908:    return insert(__pos1, __str.data(), __str.size());
        -: 2909:}
        -: 2910:
        -: 2911:template <class _CharT, class _Traits, class _Allocator>
        -: 2912:basic_string<_CharT, _Traits, _Allocator>&
        -: 2913:basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,
        -: 2914:                                                  size_type __pos2, size_type __n)
        -: 2915:{
        -: 2916:    size_type __str_sz = __str.size();
        -: 2917:    if (__pos2 > __str_sz)
        -: 2918:        this->__throw_out_of_range();
        -: 2919:    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));
        -: 2920:}
        -: 2921:
        -: 2922:template <class _CharT, class _Traits, class _Allocator>
        -: 2923:template <class _Tp>
        -: 2924:_EnableIf
        -: 2925:<
        -: 2926:    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value  && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
        -: 2927:    basic_string<_CharT, _Traits, _Allocator>&
        -: 2928:>
        -: 2929:basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,
        -: 2930:                                                  size_type __pos2, size_type __n)
        -: 2931:{
        -: 2932:    __self_view __sv = __t;
        -: 2933:    size_type __str_sz = __sv.size();
        -: 2934:    if (__pos2 > __str_sz)
        -: 2935:        this->__throw_out_of_range();
        -: 2936:    return insert(__pos1, __sv.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));
        -: 2937:}
        -: 2938:
        -: 2939:template <class _CharT, class _Traits, class _Allocator>
        -: 2940:basic_string<_CharT, _Traits, _Allocator>&
        -: 2941:basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)
        -: 2942:{
        -: 2943:    _LIBCPP_ASSERT(__s != nullptr, "string::insert received nullptr");
        -: 2944:    return insert(__pos, __s, traits_type::length(__s));
        -: 2945:}
        -: 2946:
        -: 2947:template <class _CharT, class _Traits, class _Allocator>
        -: 2948:typename basic_string<_CharT, _Traits, _Allocator>::iterator
        -: 2949:basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)
        -: 2950:{
        -: 2951:    size_type __ip = static_cast<size_type>(__pos - begin());
        -: 2952:    size_type __sz = size();
        -: 2953:    size_type __cap = capacity();
        -: 2954:    value_type* __p;
        -: 2955:    if (__cap == __sz)
        -: 2956:    {
        -: 2957:        __grow_by(__cap, 1, __sz, __ip, 0, 1);
        -: 2958:        __p = _VSTD::__to_address(__get_long_pointer());
        -: 2959:    }
        -: 2960:    else
        -: 2961:    {
        -: 2962:        __p = _VSTD::__to_address(__get_pointer());
        -: 2963:        size_type __n_move = __sz - __ip;
        -: 2964:        if (__n_move != 0)
        -: 2965:            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
        -: 2966:    }
        -: 2967:    traits_type::assign(__p[__ip], __c);
        -: 2968:    traits_type::assign(__p[++__sz], value_type());
        -: 2969:    __set_size(__sz);
        -: 2970:    return begin() + static_cast<difference_type>(__ip);
        -: 2971:}
        -: 2972:
        -: 2973:template <class _CharT, class _Traits, class _Allocator>
        -: 2974:inline
        -: 2975:typename basic_string<_CharT, _Traits, _Allocator>::iterator
        -: 2976:basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)
        -: 2977:{
        -: 2978:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 2979:    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,
        -: 2980:        "string::insert(iterator, n, value) called with an iterator not"
        -: 2981:        " referring to this string");
        -: 2982:#endif
        -: 2983:    difference_type __p = __pos - begin();
        -: 2984:    insert(static_cast<size_type>(__p), __n, __c);
        -: 2985:    return begin() + __p;
        -: 2986:}
        -: 2987:
        -: 2988:// replace
        -: 2989:
        -: 2990:template <class _CharT, class _Traits, class _Allocator>
        -: 2991:basic_string<_CharT, _Traits, _Allocator>&
        -: 2992:basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)
        -: 2993:    _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
        -: 2994:{
        -: 2995:    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, "string::replace received nullptr");
        -: 2996:    size_type __sz = size();
        -: 2997:    if (__pos > __sz)
        -: 2998:        this->__throw_out_of_range();
        -: 2999:    __n1 = _VSTD::min(__n1, __sz - __pos);
        -: 3000:    size_type __cap = capacity();
        -: 3001:    if (__cap - __sz + __n1 >= __n2)
        -: 3002:    {
        -: 3003:        value_type* __p = _VSTD::__to_address(__get_pointer());
        -: 3004:        if (__n1 != __n2)
        -: 3005:        {
        -: 3006:            size_type __n_move = __sz - __pos - __n1;
        -: 3007:            if (__n_move != 0)
        -: 3008:            {
        -: 3009:                if (__n1 > __n2)
        -: 3010:                {
        -: 3011:                    traits_type::move(__p + __pos, __s, __n2);
        -: 3012:                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
        -: 3013:                    goto __finish;
        -: 3014:                }
        -: 3015:                if (__p + __pos < __s && __s < __p + __sz)
        -: 3016:                {
        -: 3017:                    if (__p + __pos + __n1 <= __s)
        -: 3018:                        __s += __n2 - __n1;
        -: 3019:                    else // __p + __pos < __s < __p + __pos + __n1
        -: 3020:                    {
        -: 3021:                        traits_type::move(__p + __pos, __s, __n1);
        -: 3022:                        __pos += __n1;
        -: 3023:                        __s += __n2;
        -: 3024:                        __n2 -= __n1;
        -: 3025:                        __n1 = 0;
        -: 3026:                    }
        -: 3027:                }
        -: 3028:                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
        -: 3029:            }
        -: 3030:        }
        -: 3031:        traits_type::move(__p + __pos, __s, __n2);
        -: 3032:__finish:
        -: 3033:// __sz += __n2 - __n1; in this and the below function below can cause unsigned
        -: 3034:// integer overflow, but this is a safe operation, so we disable the check.
        -: 3035:        __sz += __n2 - __n1;
        -: 3036:        __set_size(__sz);
        -: 3037:        __invalidate_iterators_past(__sz);
        -: 3038:        traits_type::assign(__p[__sz], value_type());
        -: 3039:    }
        -: 3040:    else
        -: 3041:        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
        -: 3042:    return *this;
        -: 3043:}
        -: 3044:
        -: 3045:template <class _CharT, class _Traits, class _Allocator>
        -: 3046:basic_string<_CharT, _Traits, _Allocator>&
        -: 3047:basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)
        -: 3048:    _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
        -: 3049:{
        -: 3050:    size_type __sz = size();
        -: 3051:    if (__pos > __sz)
        -: 3052:        this->__throw_out_of_range();
        -: 3053:    __n1 = _VSTD::min(__n1, __sz - __pos);
        -: 3054:    size_type __cap = capacity();
        -: 3055:    value_type* __p;
        -: 3056:    if (__cap - __sz + __n1 >= __n2)
        -: 3057:    {
        -: 3058:        __p = _VSTD::__to_address(__get_pointer());
        -: 3059:        if (__n1 != __n2)
        -: 3060:        {
        -: 3061:            size_type __n_move = __sz - __pos - __n1;
        -: 3062:            if (__n_move != 0)
        -: 3063:                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
        -: 3064:        }
        -: 3065:    }
        -: 3066:    else
        -: 3067:    {
        -: 3068:        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
        -: 3069:        __p = _VSTD::__to_address(__get_long_pointer());
        -: 3070:    }
        -: 3071:    traits_type::assign(__p + __pos, __n2, __c);
        -: 3072:    __sz += __n2 - __n1;
        -: 3073:    __set_size(__sz);
        -: 3074:    __invalidate_iterators_past(__sz);
        -: 3075:    traits_type::assign(__p[__sz], value_type());
        -: 3076:    return *this;
        -: 3077:}
        -: 3078:
        -: 3079:template <class _CharT, class _Traits, class _Allocator>
        -: 3080:template<class _InputIterator>
        -: 3081:_EnableIf
        -: 3082:<
        -: 3083:    __is_cpp17_input_iterator<_InputIterator>::value,
        -: 3084:    basic_string<_CharT, _Traits, _Allocator>&
        -: 3085:>
        -: 3086:basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,
        -: 3087:                                                   _InputIterator __j1, _InputIterator __j2)
        -: 3088:{
        -: 3089:    const basic_string __temp(__j1, __j2, __alloc());
        -: 3090:    return this->replace(__i1, __i2, __temp);
        -: 3091:}
        -: 3092:
        -: 3093:template <class _CharT, class _Traits, class _Allocator>
        -: 3094:inline
        -: 3095:basic_string<_CharT, _Traits, _Allocator>&
        -: 3096:basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)
        -: 3097:{
        -: 3098:    return replace(__pos1, __n1, __str.data(), __str.size());
        -: 3099:}
        -: 3100:
        -: 3101:template <class _CharT, class _Traits, class _Allocator>
        -: 3102:basic_string<_CharT, _Traits, _Allocator>&
        -: 3103:basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,
        -: 3104:                                                   size_type __pos2, size_type __n2)
        -: 3105:{
        -: 3106:    size_type __str_sz = __str.size();
        -: 3107:    if (__pos2 > __str_sz)
        -: 3108:        this->__throw_out_of_range();
        -: 3109:    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));
        -: 3110:}
        -: 3111:
        -: 3112:template <class _CharT, class _Traits, class _Allocator>
        -: 3113:template <class _Tp>
        -: 3114:_EnableIf
        -: 3115:<
        -: 3116:    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
        -: 3117:    basic_string<_CharT, _Traits, _Allocator>&
        -: 3118:>
        -: 3119:basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,
        -: 3120:                                                   size_type __pos2, size_type __n2)
        -: 3121:{
        -: 3122:    __self_view __sv = __t;
        -: 3123:    size_type __str_sz = __sv.size();
        -: 3124:    if (__pos2 > __str_sz)
        -: 3125:        this->__throw_out_of_range();
        -: 3126:    return replace(__pos1, __n1, __sv.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));
        -: 3127:}
        -: 3128:
        -: 3129:template <class _CharT, class _Traits, class _Allocator>
        -: 3130:basic_string<_CharT, _Traits, _Allocator>&
        -: 3131:basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)
        -: 3132:{
        -: 3133:    _LIBCPP_ASSERT(__s != nullptr, "string::replace received nullptr");
        -: 3134:    return replace(__pos, __n1, __s, traits_type::length(__s));
        -: 3135:}
        -: 3136:
        -: 3137:template <class _CharT, class _Traits, class _Allocator>
        -: 3138:inline
        -: 3139:basic_string<_CharT, _Traits, _Allocator>&
        -: 3140:basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)
        -: 3141:{
        -: 3142:    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),
        -: 3143:                   __str.data(), __str.size());
        -: 3144:}
        -: 3145:
        -: 3146:template <class _CharT, class _Traits, class _Allocator>
        -: 3147:inline
        -: 3148:basic_string<_CharT, _Traits, _Allocator>&
        -: 3149:basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)
        -: 3150:{
        -: 3151:    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
        -: 3152:}
        -: 3153:
        -: 3154:template <class _CharT, class _Traits, class _Allocator>
        -: 3155:inline
        -: 3156:basic_string<_CharT, _Traits, _Allocator>&
        -: 3157:basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)
        -: 3158:{
        -: 3159:    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
        -: 3160:}
        -: 3161:
        -: 3162:template <class _CharT, class _Traits, class _Allocator>
        -: 3163:inline
        -: 3164:basic_string<_CharT, _Traits, _Allocator>&
        -: 3165:basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)
        -: 3166:{
        -: 3167:    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
        -: 3168:}
        -: 3169:
        -: 3170:// erase
        -: 3171:
        -: 3172:// 'externally instantiated' erase() implementation, called when __n != npos.
        -: 3173:// Does not check __pos against size()
        -: 3174:template <class _CharT, class _Traits, class _Allocator>
        -: 3175:void
        -: 3176:basic_string<_CharT, _Traits, _Allocator>::__erase_external_with_move(
        -: 3177:    size_type __pos, size_type __n)
        -: 3178:{
        -: 3179:    if (__n)
        -: 3180:    {
        -: 3181:        size_type __sz = size();
        -: 3182:        value_type* __p = _VSTD::__to_address(__get_pointer());
        -: 3183:        __n = _VSTD::min(__n, __sz - __pos);
        -: 3184:        size_type __n_move = __sz - __pos - __n;
        -: 3185:        if (__n_move != 0)
        -: 3186:            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
        -: 3187:        __sz -= __n;
        -: 3188:        __set_size(__sz);
        -: 3189:        __invalidate_iterators_past(__sz);
        -: 3190:        traits_type::assign(__p[__sz], value_type());
        -: 3191:    }
        -: 3192:}
        -: 3193:
        -: 3194:template <class _CharT, class _Traits, class _Allocator>
        -: 3195:basic_string<_CharT, _Traits, _Allocator>&
        -: 3196:basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos,
        -: 3197:                                                 size_type __n) {
        -: 3198:  if (__pos > size()) this->__throw_out_of_range();
        -: 3199:  if (__n == npos) {
        -: 3200:    __erase_to_end(__pos);
        -: 3201:  } else {
        -: 3202:    __erase_external_with_move(__pos, __n);
        -: 3203:  }
        -: 3204:  return *this;
        -: 3205:}
        -: 3206:
        -: 3207:template <class _CharT, class _Traits, class _Allocator>
        -: 3208:inline
        -: 3209:typename basic_string<_CharT, _Traits, _Allocator>::iterator
        -: 3210:basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)
        -: 3211:{
        -: 3212:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 3213:    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,
        -: 3214:        "string::erase(iterator) called with an iterator not"
        -: 3215:        " referring to this string");
        -: 3216:#endif
        -: 3217:    _LIBCPP_ASSERT(__pos != end(),
        -: 3218:        "string::erase(iterator) called with a non-dereferenceable iterator");
        -: 3219:    iterator __b = begin();
        -: 3220:    size_type __r = static_cast<size_type>(__pos - __b);
        -: 3221:    erase(__r, 1);
        -: 3222:    return __b + static_cast<difference_type>(__r);
        -: 3223:}
        -: 3224:
        -: 3225:template <class _CharT, class _Traits, class _Allocator>
        -: 3226:inline
        -: 3227:typename basic_string<_CharT, _Traits, _Allocator>::iterator
        -: 3228:basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)
        -: 3229:{
        -: 3230:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 3231:    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,
        -: 3232:        "string::erase(iterator,  iterator) called with an iterator not"
        -: 3233:        " referring to this string");
        -: 3234:#endif
        -: 3235:    _LIBCPP_ASSERT(__first <= __last, "string::erase(first, last) called with invalid range");
        -: 3236:    iterator __b = begin();
        -: 3237:    size_type __r = static_cast<size_type>(__first - __b);
        -: 3238:    erase(__r, static_cast<size_type>(__last - __first));
        -: 3239:    return __b + static_cast<difference_type>(__r);
        -: 3240:}
        -: 3241:
        -: 3242:template <class _CharT, class _Traits, class _Allocator>
        -: 3243:inline
        -: 3244:void
        -: 3245:basic_string<_CharT, _Traits, _Allocator>::pop_back()
        -: 3246:{
        -: 3247:    _LIBCPP_ASSERT(!empty(), "string::pop_back(): string is already empty");
        -: 3248:    size_type __sz;
        -: 3249:    if (__is_long())
        -: 3250:    {
        -: 3251:        __sz = __get_long_size() - 1;
        -: 3252:        __set_long_size(__sz);
        -: 3253:        traits_type::assign(*(__get_long_pointer() + __sz), value_type());
        -: 3254:    }
        -: 3255:    else
        -: 3256:    {
        -: 3257:        __sz = __get_short_size() - 1;
        -: 3258:        __set_short_size(__sz);
        -: 3259:        traits_type::assign(*(__get_short_pointer() + __sz), value_type());
        -: 3260:    }
        -: 3261:    __invalidate_iterators_past(__sz);
        -: 3262:}
        -: 3263:
        -: 3264:template <class _CharT, class _Traits, class _Allocator>
        -: 3265:inline
        -: 3266:void
        -: 3267:basic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT
        -: 3268:{
        -: 3269:    __invalidate_all_iterators();
        -: 3270:    if (__is_long())
        -: 3271:    {
        -: 3272:        traits_type::assign(*__get_long_pointer(), value_type());
        -: 3273:        __set_long_size(0);
        -: 3274:    }
        -: 3275:    else
        -: 3276:    {
        -: 3277:        traits_type::assign(*__get_short_pointer(), value_type());
        -: 3278:        __set_short_size(0);
        -: 3279:    }
        -: 3280:}
        -: 3281:
        -: 3282:template <class _CharT, class _Traits, class _Allocator>
        -: 3283:inline
        -: 3284:void
        -: 3285:basic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)
        -: 3286:{
        -: 3287:    if (__is_long())
        -: 3288:    {
        -: 3289:        traits_type::assign(*(__get_long_pointer() + __pos), value_type());
        -: 3290:        __set_long_size(__pos);
        -: 3291:    }
        -: 3292:    else
        -: 3293:    {
        -: 3294:        traits_type::assign(*(__get_short_pointer() + __pos), value_type());
        -: 3295:        __set_short_size(__pos);
        -: 3296:    }
        -: 3297:    __invalidate_iterators_past(__pos);
        -: 3298:}
        -: 3299:
        -: 3300:template <class _CharT, class _Traits, class _Allocator>
        -: 3301:void
        -: 3302:basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)
        -: 3303:{
        -: 3304:    size_type __sz = size();
        -: 3305:    if (__n > __sz)
        -: 3306:        append(__n - __sz, __c);
        -: 3307:    else
        -: 3308:        __erase_to_end(__n);
        -: 3309:}
        -: 3310:
        -: 3311:template <class _CharT, class _Traits, class _Allocator>
        -: 3312:inline void
        -: 3313:basic_string<_CharT, _Traits, _Allocator>::__resize_default_init(size_type __n)
        -: 3314:{
        -: 3315:    size_type __sz = size();
        -: 3316:    if (__n > __sz) {
        -: 3317:       __append_default_init(__n - __sz);
        -: 3318:    } else
        -: 3319:        __erase_to_end(__n);
        -: 3320:}
        -: 3321:
        -: 3322:template <class _CharT, class _Traits, class _Allocator>
        -: 3323:inline
        -: 3324:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3325:basic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT
        -: 3326:{
        -: 3327:    size_type __m = __alloc_traits::max_size(__alloc());
        -: 3328:#ifdef _LIBCPP_BIG_ENDIAN
        -: 3329:    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;
        -: 3330:#else
        -: 3331:    return __m - __alignment;
        -: 3332:#endif
        -: 3333:}
        -: 3334:
        -: 3335:template <class _CharT, class _Traits, class _Allocator>
        -: 3336:void
        -: 3337:basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __requested_capacity)
        -: 3338:{
        -: 3339:    if (__requested_capacity > max_size())
        -: 3340:        this->__throw_length_error();
        -: 3341:
        -: 3342:#if _LIBCPP_STD_VER > 17
        -: 3343:    // Reserve never shrinks as of C++20.
        -: 3344:    if (__requested_capacity <= capacity()) return;
        -: 3345:#endif
        -: 3346:
        -: 3347:    size_type __target_capacity = _VSTD::max(__requested_capacity, size());
        -: 3348:    __target_capacity = __recommend(__target_capacity);
        -: 3349:    if (__target_capacity == capacity()) return;
        -: 3350:
        -: 3351:    __shrink_or_extend(__target_capacity);
        -: 3352:}
        -: 3353:
        -: 3354:template <class _CharT, class _Traits, class _Allocator>
        -: 3355:inline
        -: 3356:void
        -: 3357:basic_string<_CharT, _Traits, _Allocator>::shrink_to_fit() _NOEXCEPT
        -: 3358:{
        -: 3359:    size_type __target_capacity = __recommend(size());
        -: 3360:    if (__target_capacity == capacity()) return;
        -: 3361:
        -: 3362:    __shrink_or_extend(__target_capacity);
        -: 3363:}
        -: 3364:
        -: 3365:template <class _CharT, class _Traits, class _Allocator>
        -: 3366:inline
        -: 3367:void
        -: 3368:basic_string<_CharT, _Traits, _Allocator>::__shrink_or_extend(size_type __target_capacity)
        -: 3369:{
        -: 3370:    size_type __cap = capacity();
        -: 3371:    size_type __sz = size();
        -: 3372:
        -: 3373:    pointer __new_data, __p;
        -: 3374:    bool __was_long, __now_long;
        -: 3375:    if (__target_capacity == __min_cap - 1)
        -: 3376:    {
        -: 3377:        __was_long = true;
        -: 3378:        __now_long = false;
        -: 3379:        __new_data = __get_short_pointer();
        -: 3380:        __p = __get_long_pointer();
        -: 3381:    }
        -: 3382:    else
        -: 3383:    {
        -: 3384:        if (__target_capacity > __cap)
        -: 3385:            __new_data = __alloc_traits::allocate(__alloc(), __target_capacity+1);
        -: 3386:        else
        -: 3387:        {
        -: 3388:        #ifndef _LIBCPP_NO_EXCEPTIONS
        -: 3389:            try
        -: 3390:            {
        -: 3391:        #endif // _LIBCPP_NO_EXCEPTIONS
        -: 3392:                __new_data = __alloc_traits::allocate(__alloc(), __target_capacity+1);
        -: 3393:        #ifndef _LIBCPP_NO_EXCEPTIONS
        -: 3394:            }
        -: 3395:            catch (...)
        -: 3396:            {
        -: 3397:                return;
        -: 3398:            }
        -: 3399:        #else  // _LIBCPP_NO_EXCEPTIONS
        -: 3400:            if (__new_data == nullptr)
        -: 3401:                return;
        -: 3402:        #endif // _LIBCPP_NO_EXCEPTIONS
        -: 3403:        }
        -: 3404:        __now_long = true;
        -: 3405:        __was_long = __is_long();
        -: 3406:        __p = __get_pointer();
        -: 3407:    }
        -: 3408:    traits_type::copy(_VSTD::__to_address(__new_data),
        -: 3409:                        _VSTD::__to_address(__p), size()+1);
        -: 3410:    if (__was_long)
        -: 3411:        __alloc_traits::deallocate(__alloc(), __p, __cap+1);
        -: 3412:    if (__now_long)
        -: 3413:    {
        -: 3414:        __set_long_cap(__target_capacity+1);
        -: 3415:        __set_long_size(__sz);
        -: 3416:        __set_long_pointer(__new_data);
        -: 3417:    }
        -: 3418:    else
        -: 3419:        __set_short_size(__sz);
        -: 3420:    __invalidate_all_iterators();
        -: 3421:}
        -: 3422:
        -: 3423:template <class _CharT, class _Traits, class _Allocator>
        -: 3424:inline
        -: 3425:typename basic_string<_CharT, _Traits, _Allocator>::const_reference
        -: 3426:basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const _NOEXCEPT
        -: 3427:{
        -: 3428:    _LIBCPP_ASSERT(__pos <= size(), "string index out of bounds");
        -: 3429:    return *(data() + __pos);
        -: 3430:}
        -: 3431:
        -: 3432:template <class _CharT, class _Traits, class _Allocator>
        -: 3433:inline
        -: 3434:typename basic_string<_CharT, _Traits, _Allocator>::reference
        -: 3435:basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) _NOEXCEPT
        -: 3436:{
        -: 3437:    _LIBCPP_ASSERT(__pos <= size(), "string index out of bounds");
        -: 3438:    return *(__get_pointer() + __pos);
        -: 3439:}
        -: 3440:
        -: 3441:template <class _CharT, class _Traits, class _Allocator>
        -: 3442:typename basic_string<_CharT, _Traits, _Allocator>::const_reference
        -: 3443:basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const
        -: 3444:{
        -: 3445:    if (__n >= size())
        -: 3446:        this->__throw_out_of_range();
        -: 3447:    return (*this)[__n];
        -: 3448:}
        -: 3449:
        -: 3450:template <class _CharT, class _Traits, class _Allocator>
        -: 3451:typename basic_string<_CharT, _Traits, _Allocator>::reference
        -: 3452:basic_string<_CharT, _Traits, _Allocator>::at(size_type __n)
        -: 3453:{
        -: 3454:    if (__n >= size())
        -: 3455:        this->__throw_out_of_range();
        -: 3456:    return (*this)[__n];
        -: 3457:}
        -: 3458:
        -: 3459:template <class _CharT, class _Traits, class _Allocator>
        -: 3460:inline
        -: 3461:typename basic_string<_CharT, _Traits, _Allocator>::reference
        -: 3462:basic_string<_CharT, _Traits, _Allocator>::front() _NOEXCEPT
        -: 3463:{
        -: 3464:    _LIBCPP_ASSERT(!empty(), "string::front(): string is empty");
        -: 3465:    return *__get_pointer();
        -: 3466:}
        -: 3467:
        -: 3468:template <class _CharT, class _Traits, class _Allocator>
        -: 3469:inline
        -: 3470:typename basic_string<_CharT, _Traits, _Allocator>::const_reference
        -: 3471:basic_string<_CharT, _Traits, _Allocator>::front() const _NOEXCEPT
        -: 3472:{
        -: 3473:    _LIBCPP_ASSERT(!empty(), "string::front(): string is empty");
        -: 3474:    return *data();
        -: 3475:}
        -: 3476:
        -: 3477:template <class _CharT, class _Traits, class _Allocator>
        -: 3478:inline
        -: 3479:typename basic_string<_CharT, _Traits, _Allocator>::reference
        -: 3480:basic_string<_CharT, _Traits, _Allocator>::back() _NOEXCEPT
        -: 3481:{
        -: 3482:    _LIBCPP_ASSERT(!empty(), "string::back(): string is empty");
        -: 3483:    return *(__get_pointer() + size() - 1);
        -: 3484:}
        -: 3485:
        -: 3486:template <class _CharT, class _Traits, class _Allocator>
        -: 3487:inline
        -: 3488:typename basic_string<_CharT, _Traits, _Allocator>::const_reference
        -: 3489:basic_string<_CharT, _Traits, _Allocator>::back() const _NOEXCEPT
        -: 3490:{
        -: 3491:    _LIBCPP_ASSERT(!empty(), "string::back(): string is empty");
        -: 3492:    return *(data() + size() - 1);
        -: 3493:}
        -: 3494:
        -: 3495:template <class _CharT, class _Traits, class _Allocator>
        -: 3496:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3497:basic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const
        -: 3498:{
        -: 3499:    size_type __sz = size();
        -: 3500:    if (__pos > __sz)
        -: 3501:        this->__throw_out_of_range();
        -: 3502:    size_type __rlen = _VSTD::min(__n, __sz - __pos);
        -: 3503:    traits_type::copy(__s, data() + __pos, __rlen);
        -: 3504:    return __rlen;
        -: 3505:}
        -: 3506:
        -: 3507:template <class _CharT, class _Traits, class _Allocator>
        -: 3508:inline
        -: 3509:basic_string<_CharT, _Traits, _Allocator>
        -: 3510:basic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const
        -: 3511:{
        -: 3512:    return basic_string(*this, __pos, __n, __alloc());
        -: 3513:}
        -: 3514:
        -: 3515:template <class _CharT, class _Traits, class _Allocator>
        -: 3516:inline
        -: 3517:void
        -: 3518:basic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)
        -: 3519:#if _LIBCPP_STD_VER >= 14
        -: 3520:        _NOEXCEPT
        -: 3521:#else
        -: 3522:        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||
        -: 3523:                    __is_nothrow_swappable<allocator_type>::value)
        -: 3524:#endif
        -: 3525:{
        -: 3526:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 3527:    if (!__is_long())
        -: 3528:        __get_db()->__invalidate_all(this);
        -: 3529:    if (!__str.__is_long())
        -: 3530:        __get_db()->__invalidate_all(&__str);
        -: 3531:    __get_db()->swap(this, &__str);
        -: 3532:#endif
        -: 3533:    _LIBCPP_ASSERT(
        -: 3534:        __alloc_traits::propagate_on_container_swap::value ||
        -: 3535:        __alloc_traits::is_always_equal::value ||
        -: 3536:        __alloc() == __str.__alloc(), "swapping non-equal allocators");
        -: 3537:    _VSTD::swap(__r_.first(), __str.__r_.first());
        -: 3538:    _VSTD::__swap_allocator(__alloc(), __str.__alloc());
        -: 3539:}
        -: 3540:
        -: 3541:// find
        -: 3542:
        -: 3543:template <class _Traits>
        -: 3544:struct _LIBCPP_HIDDEN __traits_eq
        -: 3545:{
        -: 3546:    typedef typename _Traits::char_type char_type;
        -: 3547:    _LIBCPP_INLINE_VISIBILITY
        -: 3548:    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT
        -: 3549:        {return _Traits::eq(__x, __y);}
        -: 3550:};
        -: 3551:
        -: 3552:template<class _CharT, class _Traits, class _Allocator>
        -: 3553:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3554:basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
        -: 3555:                                                size_type __pos,
        -: 3556:                                                size_type __n) const _NOEXCEPT
        -: 3557:{
        -: 3558:    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::find(): received nullptr");
        -: 3559:    return __str_find<value_type, size_type, traits_type, npos>
        -: 3560:        (data(), size(), __s, __pos, __n);
        -: 3561:}
        -: 3562:
        -: 3563:template<class _CharT, class _Traits, class _Allocator>
        -: 3564:inline
        -: 3565:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3566:basic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,
        -: 3567:                                                size_type __pos) const _NOEXCEPT
        -: 3568:{
        -: 3569:    return __str_find<value_type, size_type, traits_type, npos>
        -: 3570:        (data(), size(), __str.data(), __pos, __str.size());
        -: 3571:}
        -: 3572:
        -: 3573:template<class _CharT, class _Traits, class _Allocator>
        -: 3574:template <class _Tp>
        -: 3575:_EnableIf
        -: 3576:<
        -: 3577:    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 3578:    typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3579:>
        -: 3580:basic_string<_CharT, _Traits, _Allocator>::find(const _Tp &__t,
        -: 3581:                                                size_type __pos) const _NOEXCEPT
        -: 3582:{
        -: 3583:    __self_view __sv = __t;
        -: 3584:    return __str_find<value_type, size_type, traits_type, npos>
        -: 3585:        (data(), size(), __sv.data(), __pos, __sv.size());
        -: 3586:}
        -: 3587:
        -: 3588:template<class _CharT, class _Traits, class _Allocator>
        -: 3589:inline
        -: 3590:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3591:basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
        -: 3592:                                                size_type __pos) const _NOEXCEPT
        -: 3593:{
        -: 3594:    _LIBCPP_ASSERT(__s != nullptr, "string::find(): received nullptr");
        -: 3595:    return __str_find<value_type, size_type, traits_type, npos>
        -: 3596:        (data(), size(), __s, __pos, traits_type::length(__s));
        -: 3597:}
        -: 3598:
        -: 3599:template<class _CharT, class _Traits, class _Allocator>
        -: 3600:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3601:basic_string<_CharT, _Traits, _Allocator>::find(value_type __c,
        -: 3602:                                                size_type __pos) const _NOEXCEPT
        -: 3603:{
        -: 3604:    return __str_find<value_type, size_type, traits_type, npos>
        -: 3605:        (data(), size(), __c, __pos);
        -: 3606:}
        -: 3607:
        -: 3608:// rfind
        -: 3609:
        -: 3610:template<class _CharT, class _Traits, class _Allocator>
        -: 3611:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3612:basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
        -: 3613:                                                 size_type __pos,
        -: 3614:                                                 size_type __n) const _NOEXCEPT
        -: 3615:{
        -: 3616:    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::rfind(): received nullptr");
        -: 3617:    return __str_rfind<value_type, size_type, traits_type, npos>
        -: 3618:        (data(), size(), __s, __pos, __n);
        -: 3619:}
        -: 3620:
        -: 3621:template<class _CharT, class _Traits, class _Allocator>
        -: 3622:inline
        -: 3623:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3624:basic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,
        -: 3625:                                                 size_type __pos) const _NOEXCEPT
        -: 3626:{
        -: 3627:    return __str_rfind<value_type, size_type, traits_type, npos>
        -: 3628:        (data(), size(), __str.data(), __pos, __str.size());
        -: 3629:}
        -: 3630:
        -: 3631:template<class _CharT, class _Traits, class _Allocator>
        -: 3632:template <class _Tp>
        -: 3633:_EnableIf
        -: 3634:<
        -: 3635:    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 3636:    typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3637:>
        -: 3638:basic_string<_CharT, _Traits, _Allocator>::rfind(const _Tp& __t,
        -: 3639:                                                size_type __pos) const _NOEXCEPT
        -: 3640:{
        -: 3641:    __self_view __sv = __t;
        -: 3642:    return __str_rfind<value_type, size_type, traits_type, npos>
        -: 3643:        (data(), size(), __sv.data(), __pos, __sv.size());
        -: 3644:}
        -: 3645:
        -: 3646:template<class _CharT, class _Traits, class _Allocator>
        -: 3647:inline
        -: 3648:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3649:basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
        -: 3650:                                                 size_type __pos) const _NOEXCEPT
        -: 3651:{
        -: 3652:    _LIBCPP_ASSERT(__s != nullptr, "string::rfind(): received nullptr");
        -: 3653:    return __str_rfind<value_type, size_type, traits_type, npos>
        -: 3654:        (data(), size(), __s, __pos, traits_type::length(__s));
        -: 3655:}
        -: 3656:
        -: 3657:template<class _CharT, class _Traits, class _Allocator>
        -: 3658:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3659:basic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,
        -: 3660:                                                 size_type __pos) const _NOEXCEPT
        -: 3661:{
        -: 3662:    return __str_rfind<value_type, size_type, traits_type, npos>
        -: 3663:        (data(), size(), __c, __pos);
        -: 3664:}
        -: 3665:
        -: 3666:// find_first_of
        -: 3667:
        -: 3668:template<class _CharT, class _Traits, class _Allocator>
        -: 3669:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3670:basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
        -: 3671:                                                         size_type __pos,
        -: 3672:                                                         size_type __n) const _NOEXCEPT
        -: 3673:{
        -: 3674:    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::find_first_of(): received nullptr");
        -: 3675:    return __str_find_first_of<value_type, size_type, traits_type, npos>
        -: 3676:        (data(), size(), __s, __pos, __n);
        -: 3677:}
        -: 3678:
        -: 3679:template<class _CharT, class _Traits, class _Allocator>
        -: 3680:inline
        -: 3681:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3682:basic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,
        -: 3683:                                                         size_type __pos) const _NOEXCEPT
        -: 3684:{
        -: 3685:    return __str_find_first_of<value_type, size_type, traits_type, npos>
        -: 3686:        (data(), size(), __str.data(), __pos, __str.size());
        -: 3687:}
        -: 3688:
        -: 3689:template<class _CharT, class _Traits, class _Allocator>
        -: 3690:template <class _Tp>
        -: 3691:_EnableIf
        -: 3692:<
        -: 3693:    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 3694:    typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3695:>
        -: 3696:basic_string<_CharT, _Traits, _Allocator>::find_first_of(const _Tp& __t,
        -: 3697:                                                size_type __pos) const _NOEXCEPT
        -: 3698:{
        -: 3699:    __self_view __sv = __t;
        -: 3700:    return __str_find_first_of<value_type, size_type, traits_type, npos>
        -: 3701:        (data(), size(), __sv.data(), __pos, __sv.size());
        -: 3702:}
        -: 3703:
        -: 3704:template<class _CharT, class _Traits, class _Allocator>
        -: 3705:inline
        -: 3706:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3707:basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
        -: 3708:                                                         size_type __pos) const _NOEXCEPT
        -: 3709:{
        -: 3710:    _LIBCPP_ASSERT(__s != nullptr, "string::find_first_of(): received nullptr");
        -: 3711:    return __str_find_first_of<value_type, size_type, traits_type, npos>
        -: 3712:        (data(), size(), __s, __pos, traits_type::length(__s));
        -: 3713:}
        -: 3714:
        -: 3715:template<class _CharT, class _Traits, class _Allocator>
        -: 3716:inline
        -: 3717:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3718:basic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,
        -: 3719:                                                         size_type __pos) const _NOEXCEPT
        -: 3720:{
        -: 3721:    return find(__c, __pos);
        -: 3722:}
        -: 3723:
        -: 3724:// find_last_of
        -: 3725:
        -: 3726:template<class _CharT, class _Traits, class _Allocator>
        -: 3727:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3728:basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
        -: 3729:                                                        size_type __pos,
        -: 3730:                                                        size_type __n) const _NOEXCEPT
        -: 3731:{
        -: 3732:    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::find_last_of(): received nullptr");
        -: 3733:    return __str_find_last_of<value_type, size_type, traits_type, npos>
        -: 3734:        (data(), size(), __s, __pos, __n);
        -: 3735:}
        -: 3736:
        -: 3737:template<class _CharT, class _Traits, class _Allocator>
        -: 3738:inline
        -: 3739:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3740:basic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,
        -: 3741:                                                        size_type __pos) const _NOEXCEPT
        -: 3742:{
        -: 3743:    return __str_find_last_of<value_type, size_type, traits_type, npos>
        -: 3744:        (data(), size(), __str.data(), __pos, __str.size());
        -: 3745:}
        -: 3746:
        -: 3747:template<class _CharT, class _Traits, class _Allocator>
        -: 3748:template <class _Tp>
        -: 3749:_EnableIf
        -: 3750:<
        -: 3751:    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 3752:    typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3753:>
        -: 3754:basic_string<_CharT, _Traits, _Allocator>::find_last_of(const _Tp& __t,
        -: 3755:                                                size_type __pos) const _NOEXCEPT
        -: 3756:{
        -: 3757:    __self_view __sv = __t;
        -: 3758:    return __str_find_last_of<value_type, size_type, traits_type, npos>
        -: 3759:        (data(), size(), __sv.data(), __pos, __sv.size());
        -: 3760:}
        -: 3761:
        -: 3762:template<class _CharT, class _Traits, class _Allocator>
        -: 3763:inline
        -: 3764:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3765:basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
        -: 3766:                                                        size_type __pos) const _NOEXCEPT
        -: 3767:{
        -: 3768:    _LIBCPP_ASSERT(__s != nullptr, "string::find_last_of(): received nullptr");
        -: 3769:    return __str_find_last_of<value_type, size_type, traits_type, npos>
        -: 3770:        (data(), size(), __s, __pos, traits_type::length(__s));
        -: 3771:}
        -: 3772:
        -: 3773:template<class _CharT, class _Traits, class _Allocator>
        -: 3774:inline
        -: 3775:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3776:basic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,
        -: 3777:                                                        size_type __pos) const _NOEXCEPT
        -: 3778:{
        -: 3779:    return rfind(__c, __pos);
        -: 3780:}
        -: 3781:
        -: 3782:// find_first_not_of
        -: 3783:
        -: 3784:template<class _CharT, class _Traits, class _Allocator>
        -: 3785:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3786:basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
        -: 3787:                                                             size_type __pos,
        -: 3788:                                                             size_type __n) const _NOEXCEPT
        -: 3789:{
        -: 3790:    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::find_first_not_of(): received nullptr");
        -: 3791:    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        -: 3792:        (data(), size(), __s, __pos, __n);
        -: 3793:}
        -: 3794:
        -: 3795:template<class _CharT, class _Traits, class _Allocator>
        -: 3796:inline
        -: 3797:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3798:basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,
        -: 3799:                                                             size_type __pos) const _NOEXCEPT
        -: 3800:{
        -: 3801:    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        -: 3802:        (data(), size(), __str.data(), __pos, __str.size());
        -: 3803:}
        -: 3804:
        -: 3805:template<class _CharT, class _Traits, class _Allocator>
        -: 3806:template <class _Tp>
        -: 3807:_EnableIf
        -: 3808:<
        -: 3809:    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 3810:    typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3811:>
        -: 3812:basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const _Tp& __t,
        -: 3813:                                                size_type __pos) const _NOEXCEPT
        -: 3814:{
        -: 3815:    __self_view __sv = __t;
        -: 3816:    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        -: 3817:        (data(), size(), __sv.data(), __pos, __sv.size());
        -: 3818:}
        -: 3819:
        -: 3820:template<class _CharT, class _Traits, class _Allocator>
        -: 3821:inline
        -: 3822:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3823:basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
        -: 3824:                                                             size_type __pos) const _NOEXCEPT
        -: 3825:{
        -: 3826:    _LIBCPP_ASSERT(__s != nullptr, "string::find_first_not_of(): received nullptr");
        -: 3827:    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        -: 3828:        (data(), size(), __s, __pos, traits_type::length(__s));
        -: 3829:}
        -: 3830:
        -: 3831:template<class _CharT, class _Traits, class _Allocator>
        -: 3832:inline
        -: 3833:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3834:basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,
        -: 3835:                                                             size_type __pos) const _NOEXCEPT
        -: 3836:{
        -: 3837:    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        -: 3838:        (data(), size(), __c, __pos);
        -: 3839:}
        -: 3840:
        -: 3841:// find_last_not_of
        -: 3842:
        -: 3843:template<class _CharT, class _Traits, class _Allocator>
        -: 3844:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3845:basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
        -: 3846:                                                            size_type __pos,
        -: 3847:                                                            size_type __n) const _NOEXCEPT
        -: 3848:{
        -: 3849:    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::find_last_not_of(): received nullptr");
        -: 3850:    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        -: 3851:        (data(), size(), __s, __pos, __n);
        -: 3852:}
        -: 3853:
        -: 3854:template<class _CharT, class _Traits, class _Allocator>
        -: 3855:inline
        -: 3856:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3857:basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,
        -: 3858:                                                            size_type __pos) const _NOEXCEPT
        -: 3859:{
        -: 3860:    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        -: 3861:        (data(), size(), __str.data(), __pos, __str.size());
        -: 3862:}
        -: 3863:
        -: 3864:template<class _CharT, class _Traits, class _Allocator>
        -: 3865:template <class _Tp>
        -: 3866:_EnableIf
        -: 3867:<
        -: 3868:    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 3869:    typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3870:>
        -: 3871:basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const _Tp& __t,
        -: 3872:                                                size_type __pos) const _NOEXCEPT
        -: 3873:{
        -: 3874:    __self_view __sv = __t;
        -: 3875:    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        -: 3876:        (data(), size(), __sv.data(), __pos, __sv.size());
        -: 3877:}
        -: 3878:
        -: 3879:template<class _CharT, class _Traits, class _Allocator>
        -: 3880:inline
        -: 3881:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3882:basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
        -: 3883:                                                            size_type __pos) const _NOEXCEPT
        -: 3884:{
        -: 3885:    _LIBCPP_ASSERT(__s != nullptr, "string::find_last_not_of(): received nullptr");
        -: 3886:    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        -: 3887:        (data(), size(), __s, __pos, traits_type::length(__s));
        -: 3888:}
        -: 3889:
        -: 3890:template<class _CharT, class _Traits, class _Allocator>
        -: 3891:inline
        -: 3892:typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 3893:basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,
        -: 3894:                                                            size_type __pos) const _NOEXCEPT
        -: 3895:{
        -: 3896:    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        -: 3897:        (data(), size(), __c, __pos);
        -: 3898:}
        -: 3899:
        -: 3900:// compare
        -: 3901:
        -: 3902:template <class _CharT, class _Traits, class _Allocator>
        -: 3903:template <class _Tp>
        -: 3904:_EnableIf
        -: 3905:<
        -: 3906:    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 3907:    int
        -: 3908:>
        -: 3909:basic_string<_CharT, _Traits, _Allocator>::compare(const _Tp& __t) const _NOEXCEPT
        -: 3910:{
        -: 3911:    __self_view __sv = __t;
        -: 3912:    size_t __lhs_sz = size();
        -: 3913:    size_t __rhs_sz = __sv.size();
        -: 3914:    int __result = traits_type::compare(data(), __sv.data(),
        -: 3915:                                        _VSTD::min(__lhs_sz, __rhs_sz));
        -: 3916:    if (__result != 0)
        -: 3917:        return __result;
        -: 3918:    if (__lhs_sz < __rhs_sz)
        -: 3919:        return -1;
        -: 3920:    if (__lhs_sz > __rhs_sz)
        -: 3921:        return 1;
        -: 3922:    return 0;
        -: 3923:}
        -: 3924:
        -: 3925:template <class _CharT, class _Traits, class _Allocator>
        -: 3926:inline
        -: 3927:int
        -: 3928:basic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT
        -: 3929:{
        -: 3930:    return compare(__self_view(__str));
        -: 3931:}
        -: 3932:
        -: 3933:template <class _CharT, class _Traits, class _Allocator>
        -: 3934:int
        -: 3935:basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
        -: 3936:                                                   size_type __n1,
        -: 3937:                                                   const value_type* __s,
        -: 3938:                                                   size_type __n2) const
        -: 3939:{
        -: 3940:    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, "string::compare(): received nullptr");
        -: 3941:    size_type __sz = size();
        -: 3942:    if (__pos1 > __sz || __n2 == npos)
        -: 3943:        this->__throw_out_of_range();
        -: 3944:    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);
        -: 3945:    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));
        -: 3946:    if (__r == 0)
        -: 3947:    {
        -: 3948:        if (__rlen < __n2)
        -: 3949:            __r = -1;
        -: 3950:        else if (__rlen > __n2)
        -: 3951:            __r = 1;
        -: 3952:    }
        -: 3953:    return __r;
        -: 3954:}
        -: 3955:
        -: 3956:template <class _CharT, class _Traits, class _Allocator>
        -: 3957:template <class _Tp>
        -: 3958:_EnableIf
        -: 3959:<
        -: 3960:    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
        -: 3961:    int
        -: 3962:>
        -: 3963:basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
        -: 3964:                                                   size_type __n1,
        -: 3965:                                                   const _Tp& __t) const
        -: 3966:{
        -: 3967:    __self_view __sv = __t;
        -: 3968:    return compare(__pos1, __n1, __sv.data(), __sv.size());
        -: 3969:}
        -: 3970:
        -: 3971:template <class _CharT, class _Traits, class _Allocator>
        -: 3972:inline
        -: 3973:int
        -: 3974:basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
        -: 3975:                                                   size_type __n1,
        -: 3976:                                                   const basic_string& __str) const
        -: 3977:{
        -: 3978:    return compare(__pos1, __n1, __str.data(), __str.size());
        -: 3979:}
        -: 3980:
        -: 3981:template <class _CharT, class _Traits, class _Allocator>
        -: 3982:template <class _Tp>
        -: 3983:_EnableIf
        -: 3984:<
        -: 3985:    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
        -: 3986:    && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
        -: 3987:    int
        -: 3988:>
        -: 3989:basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
        -: 3990:                                                   size_type __n1,
        -: 3991:                                                   const _Tp& __t,
        -: 3992:                                                   size_type __pos2,
        -: 3993:                                                   size_type __n2) const
        -: 3994:{
        -: 3995:    __self_view __sv = __t;
        -: 3996:    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
        -: 3997:}
        -: 3998:
        -: 3999:template <class _CharT, class _Traits, class _Allocator>
        -: 4000:int
        -: 4001:basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
        -: 4002:                                                   size_type __n1,
        -: 4003:                                                   const basic_string& __str,
        -: 4004:                                                   size_type __pos2,
        -: 4005:                                                   size_type __n2) const
        -: 4006:{
        -: 4007:        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);
        -: 4008:}
        -: 4009:
        -: 4010:template <class _CharT, class _Traits, class _Allocator>
        -: 4011:int
        -: 4012:basic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT
        -: 4013:{
        -: 4014:    _LIBCPP_ASSERT(__s != nullptr, "string::compare(): received nullptr");
        -: 4015:    return compare(0, npos, __s, traits_type::length(__s));
        -: 4016:}
        -: 4017:
        -: 4018:template <class _CharT, class _Traits, class _Allocator>
        -: 4019:int
        -: 4020:basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
        -: 4021:                                                   size_type __n1,
        -: 4022:                                                   const value_type* __s) const
        -: 4023:{
        -: 4024:    _LIBCPP_ASSERT(__s != nullptr, "string::compare(): received nullptr");
        -: 4025:    return compare(__pos1, __n1, __s, traits_type::length(__s));
        -: 4026:}
        -: 4027:
        -: 4028:// __invariants
        -: 4029:
        -: 4030:template<class _CharT, class _Traits, class _Allocator>
        -: 4031:inline
        -: 4032:bool
        -: 4033:basic_string<_CharT, _Traits, _Allocator>::__invariants() const
        -: 4034:{
        -: 4035:    if (size() > capacity())
        -: 4036:        return false;
        -: 4037:    if (capacity() < __min_cap - 1)
        -: 4038:        return false;
        -: 4039:    if (data() == nullptr)
        -: 4040:        return false;
        -: 4041:    if (data()[size()] != value_type())
        -: 4042:        return false;
        -: 4043:    return true;
        -: 4044:}
        -: 4045:
        -: 4046:// __clear_and_shrink
        -: 4047:
        -: 4048:template<class _CharT, class _Traits, class _Allocator>
        -: 4049:inline
        -: 4050:void
        -: 4051:basic_string<_CharT, _Traits, _Allocator>::__clear_and_shrink() _NOEXCEPT
        -: 4052:{
        -: 4053:    clear();
        -: 4054:    if(__is_long())
        -: 4055:    {
        -: 4056:        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), capacity() + 1);
        -: 4057:        __set_long_cap(0);
        -: 4058:        __set_short_size(0);
        -: 4059:        traits_type::assign(*__get_short_pointer(), value_type());
        -: 4060:    }
        -: 4061:}
        -: 4062:
        -: 4063:// operator==
        -: 4064:
        -: 4065:template<class _CharT, class _Traits, class _Allocator>
        -: 4066:inline _LIBCPP_INLINE_VISIBILITY
        -: 4067:bool
        -: 4068:operator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
        -: 4069:           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
        -: 4070:{
        -: 4071:    size_t __lhs_sz = __lhs.size();
        -: 4072:    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),
        -: 4073:                                                        __rhs.data(),
        -: 4074:                                                        __lhs_sz) == 0;
        -: 4075:}
        -: 4076:
        -: 4077:template<class _Allocator>
        -: 4078:inline _LIBCPP_INLINE_VISIBILITY
        -: 4079:bool
        -: 4080:operator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,
        -: 4081:           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT
        -: 4082:{
        -: 4083:    size_t __lhs_sz = __lhs.size();
        -: 4084:    if (__lhs_sz != __rhs.size())
        -: 4085:        return false;
        -: 4086:    const char* __lp = __lhs.data();
        -: 4087:    const char* __rp = __rhs.data();
        -: 4088:    if (__lhs.__is_long())
        -: 4089:        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
        -: 4090:    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
        -: 4091:        if (*__lp != *__rp)
        -: 4092:            return false;
        -: 4093:    return true;
        -: 4094:}
        -: 4095:
        -: 4096:template<class _CharT, class _Traits, class _Allocator>
        -: 4097:inline _LIBCPP_INLINE_VISIBILITY
        -: 4098:bool
        -: 4099:operator==(const _CharT* __lhs,
        -: 4100:           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
        -: 4101:{
        -: 4102:    typedef basic_string<_CharT, _Traits, _Allocator> _String;
        -: 4103:    _LIBCPP_ASSERT(__lhs != nullptr, "operator==(char*, basic_string): received nullptr");
        -: 4104:    size_t __lhs_len = _Traits::length(__lhs);
        -: 4105:    if (__lhs_len != __rhs.size()) return false;
        -: 4106:    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;
        -: 4107:}
        -: 4108:
        -: 4109:template<class _CharT, class _Traits, class _Allocator>
        -: 4110:inline _LIBCPP_INLINE_VISIBILITY
        -: 4111:bool
        -: 4112:operator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
        -: 4113:           const _CharT* __rhs) _NOEXCEPT
        -: 4114:{
        -: 4115:    typedef basic_string<_CharT, _Traits, _Allocator> _String;
        -: 4116:    _LIBCPP_ASSERT(__rhs != nullptr, "operator==(basic_string, char*): received nullptr");
        -: 4117:    size_t __rhs_len = _Traits::length(__rhs);
        -: 4118:    if (__rhs_len != __lhs.size()) return false;
        -: 4119:    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;
        -: 4120:}
        -: 4121:
        -: 4122:template<class _CharT, class _Traits, class _Allocator>
        -: 4123:inline _LIBCPP_INLINE_VISIBILITY
        -: 4124:bool
        -: 4125:operator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
        -: 4126:           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
        -: 4127:{
        -: 4128:    return !(__lhs == __rhs);
        -: 4129:}
        -: 4130:
        -: 4131:template<class _CharT, class _Traits, class _Allocator>
        -: 4132:inline _LIBCPP_INLINE_VISIBILITY
        -: 4133:bool
        -: 4134:operator!=(const _CharT* __lhs,
        -: 4135:           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
        -: 4136:{
        -: 4137:    return !(__lhs == __rhs);
        -: 4138:}
        -: 4139:
        -: 4140:template<class _CharT, class _Traits, class _Allocator>
        -: 4141:inline _LIBCPP_INLINE_VISIBILITY
        -: 4142:bool
        -: 4143:operator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
        -: 4144:           const _CharT* __rhs) _NOEXCEPT
        -: 4145:{
        -: 4146:    return !(__lhs == __rhs);
        -: 4147:}
        -: 4148:
        -: 4149:// operator<
        -: 4150:
        -: 4151:template<class _CharT, class _Traits, class _Allocator>
        -: 4152:inline _LIBCPP_INLINE_VISIBILITY
        -: 4153:bool
        -: 4154:operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
        -: 4155:           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
        -: 4156:{
        -: 4157:    return __lhs.compare(__rhs) < 0;
        -: 4158:}
        -: 4159:
        -: 4160:template<class _CharT, class _Traits, class _Allocator>
        -: 4161:inline _LIBCPP_INLINE_VISIBILITY
        -: 4162:bool
        -: 4163:operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
        -: 4164:           const _CharT* __rhs) _NOEXCEPT
        -: 4165:{
        -: 4166:    return __lhs.compare(__rhs) < 0;
        -: 4167:}
        -: 4168:
        -: 4169:template<class _CharT, class _Traits, class _Allocator>
        -: 4170:inline _LIBCPP_INLINE_VISIBILITY
        -: 4171:bool
        -: 4172:operator< (const _CharT* __lhs,
        -: 4173:           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
        -: 4174:{
        -: 4175:    return __rhs.compare(__lhs) > 0;
        -: 4176:}
        -: 4177:
        -: 4178:// operator>
        -: 4179:
        -: 4180:template<class _CharT, class _Traits, class _Allocator>
        -: 4181:inline _LIBCPP_INLINE_VISIBILITY
        -: 4182:bool
        -: 4183:operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
        -: 4184:           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
        -: 4185:{
        -: 4186:    return __rhs < __lhs;
        -: 4187:}
        -: 4188:
        -: 4189:template<class _CharT, class _Traits, class _Allocator>
        -: 4190:inline _LIBCPP_INLINE_VISIBILITY
        -: 4191:bool
        -: 4192:operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
        -: 4193:           const _CharT* __rhs) _NOEXCEPT
        -: 4194:{
        -: 4195:    return __rhs < __lhs;
        -: 4196:}
        -: 4197:
        -: 4198:template<class _CharT, class _Traits, class _Allocator>
        -: 4199:inline _LIBCPP_INLINE_VISIBILITY
        -: 4200:bool
        -: 4201:operator> (const _CharT* __lhs,
        -: 4202:           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
        -: 4203:{
        -: 4204:    return __rhs < __lhs;
        -: 4205:}
        -: 4206:
        -: 4207:// operator<=
        -: 4208:
        -: 4209:template<class _CharT, class _Traits, class _Allocator>
        -: 4210:inline _LIBCPP_INLINE_VISIBILITY
        -: 4211:bool
        -: 4212:operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
        -: 4213:           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
        -: 4214:{
        -: 4215:    return !(__rhs < __lhs);
        -: 4216:}
        -: 4217:
        -: 4218:template<class _CharT, class _Traits, class _Allocator>
        -: 4219:inline _LIBCPP_INLINE_VISIBILITY
        -: 4220:bool
        -: 4221:operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
        -: 4222:           const _CharT* __rhs) _NOEXCEPT
        -: 4223:{
        -: 4224:    return !(__rhs < __lhs);
        -: 4225:}
        -: 4226:
        -: 4227:template<class _CharT, class _Traits, class _Allocator>
        -: 4228:inline _LIBCPP_INLINE_VISIBILITY
        -: 4229:bool
        -: 4230:operator<=(const _CharT* __lhs,
        -: 4231:           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
        -: 4232:{
        -: 4233:    return !(__rhs < __lhs);
        -: 4234:}
        -: 4235:
        -: 4236:// operator>=
        -: 4237:
        -: 4238:template<class _CharT, class _Traits, class _Allocator>
        -: 4239:inline _LIBCPP_INLINE_VISIBILITY
        -: 4240:bool
        -: 4241:operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
        -: 4242:           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
        -: 4243:{
        -: 4244:    return !(__lhs < __rhs);
        -: 4245:}
        -: 4246:
        -: 4247:template<class _CharT, class _Traits, class _Allocator>
        -: 4248:inline _LIBCPP_INLINE_VISIBILITY
        -: 4249:bool
        -: 4250:operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
        -: 4251:           const _CharT* __rhs) _NOEXCEPT
        -: 4252:{
        -: 4253:    return !(__lhs < __rhs);
        -: 4254:}
        -: 4255:
        -: 4256:template<class _CharT, class _Traits, class _Allocator>
        -: 4257:inline _LIBCPP_INLINE_VISIBILITY
        -: 4258:bool
        -: 4259:operator>=(const _CharT* __lhs,
        -: 4260:           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT
        -: 4261:{
        -: 4262:    return !(__lhs < __rhs);
        -: 4263:}
        -: 4264:
        -: 4265:// operator +
        -: 4266:
        -: 4267:template<class _CharT, class _Traits, class _Allocator>
        -: 4268:basic_string<_CharT, _Traits, _Allocator>
        -: 4269:operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
        -: 4270:          const basic_string<_CharT, _Traits, _Allocator>& __rhs)
        -: 4271:{
        -: 4272:    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
        -: 4273:    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
        -: 4274:    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
        -: 4275:    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
        -: 4276:    __r.append(__rhs.data(), __rhs_sz);
        -: 4277:    return __r;
        -: 4278:}
        -: 4279:
        -: 4280:template<class _CharT, class _Traits, class _Allocator>
        -: 4281:basic_string<_CharT, _Traits, _Allocator>
        -: 4282:operator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)
        -: 4283:{
        -: 4284:    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
        -: 4285:    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);
        -: 4286:    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
        -: 4287:    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
        -: 4288:    __r.append(__rhs.data(), __rhs_sz);
        -: 4289:    return __r;
        -: 4290:}
        -: 4291:
        -: 4292:template<class _CharT, class _Traits, class _Allocator>
        -: 4293:basic_string<_CharT, _Traits, _Allocator>
        -: 4294:operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)
        -: 4295:{
        -: 4296:    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
        -: 4297:    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
        -: 4298:    __r.__init(&__lhs, 1, 1 + __rhs_sz);
        -: 4299:    __r.append(__rhs.data(), __rhs_sz);
        -: 4300:    return __r;
        -: 4301:}
        -: 4302:
        -: 4303:template<class _CharT, class _Traits, class _Allocator>
        -: 4304:inline
        -: 4305:basic_string<_CharT, _Traits, _Allocator>
        -: 4306:operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)
        -: 4307:{
        -: 4308:    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
        -: 4309:    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
        -: 4310:    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);
        -: 4311:    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
        -: 4312:    __r.append(__rhs, __rhs_sz);
        -: 4313:    return __r;
        -: 4314:}
        -: 4315:
        -: 4316:template<class _CharT, class _Traits, class _Allocator>
        -: 4317:basic_string<_CharT, _Traits, _Allocator>
        -: 4318:operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)
        -: 4319:{
        -: 4320:    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
        -: 4321:    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
        -: 4322:    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
        -: 4323:    __r.push_back(__rhs);
        -: 4324:    return __r;
        -: 4325:}
        -: 4326:
        -: 4327:#ifndef _LIBCPP_CXX03_LANG
        -: 4328:
        -: 4329:template<class _CharT, class _Traits, class _Allocator>
        -: 4330:inline _LIBCPP_INLINE_VISIBILITY
        -: 4331:basic_string<_CharT, _Traits, _Allocator>
        -: 4332:operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)
        -: 4333:{
        -: 4334:    return _VSTD::move(__lhs.append(__rhs));
        -: 4335:}
        -: 4336:
        -: 4337:template<class _CharT, class _Traits, class _Allocator>
        -: 4338:inline _LIBCPP_INLINE_VISIBILITY
        -: 4339:basic_string<_CharT, _Traits, _Allocator>
        -: 4340:operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
        -: 4341:{
        -: 4342:    return _VSTD::move(__rhs.insert(0, __lhs));
        -: 4343:}
        -: 4344:
        -: 4345:template<class _CharT, class _Traits, class _Allocator>
        -: 4346:inline _LIBCPP_INLINE_VISIBILITY
        -: 4347:basic_string<_CharT, _Traits, _Allocator>
        -: 4348:operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
        -: 4349:{
        -: 4350:    return _VSTD::move(__lhs.append(__rhs));
        -: 4351:}
        -: 4352:
        -: 4353:template<class _CharT, class _Traits, class _Allocator>
        -: 4354:inline _LIBCPP_INLINE_VISIBILITY
        -: 4355:basic_string<_CharT, _Traits, _Allocator>
        -: 4356:operator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)
        -: 4357:{
        -: 4358:    return _VSTD::move(__rhs.insert(0, __lhs));
        -: 4359:}
        -: 4360:
        -: 4361:template<class _CharT, class _Traits, class _Allocator>
        -: 4362:inline _LIBCPP_INLINE_VISIBILITY
        -: 4363:basic_string<_CharT, _Traits, _Allocator>
        -: 4364:operator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)
        -: 4365:{
        -: 4366:    __rhs.insert(__rhs.begin(), __lhs);
        -: 4367:    return _VSTD::move(__rhs);
        -: 4368:}
        -: 4369:
        -: 4370:template<class _CharT, class _Traits, class _Allocator>
        -: 4371:inline _LIBCPP_INLINE_VISIBILITY
        -: 4372:basic_string<_CharT, _Traits, _Allocator>
        -: 4373:operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)
        -: 4374:{
        -: 4375:    return _VSTD::move(__lhs.append(__rhs));
        -: 4376:}
        -: 4377:
        -: 4378:template<class _CharT, class _Traits, class _Allocator>
        -: 4379:inline _LIBCPP_INLINE_VISIBILITY
        -: 4380:basic_string<_CharT, _Traits, _Allocator>
        -: 4381:operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)
        -: 4382:{
        -: 4383:    __lhs.push_back(__rhs);
        -: 4384:    return _VSTD::move(__lhs);
        -: 4385:}
        -: 4386:
        -: 4387:#endif // _LIBCPP_CXX03_LANG
        -: 4388:
        -: 4389:// swap
        -: 4390:
        -: 4391:template<class _CharT, class _Traits, class _Allocator>
        -: 4392:inline _LIBCPP_INLINE_VISIBILITY
        -: 4393:void
        -: 4394:swap(basic_string<_CharT, _Traits, _Allocator>& __lhs,
        -: 4395:     basic_string<_CharT, _Traits, _Allocator>& __rhs)
        -: 4396:     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))
        -: 4397:{
        -: 4398:    __lhs.swap(__rhs);
        -: 4399:}
        -: 4400:
        -: 4401:_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = nullptr, int __base = 10);
        -: 4402:_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = nullptr, int __base = 10);
        -: 4403:_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = nullptr, int __base = 10);
        -: 4404:_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = nullptr, int __base = 10);
        -: 4405:_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = nullptr, int __base = 10);
        -: 4406:
        -: 4407:_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = nullptr);
        -: 4408:_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = nullptr);
        -: 4409:_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = nullptr);
        -: 4410:
        -: 4411:_LIBCPP_FUNC_VIS string to_string(int __val);
        -: 4412:_LIBCPP_FUNC_VIS string to_string(unsigned __val);
        -: 4413:_LIBCPP_FUNC_VIS string to_string(long __val);
        -: 4414:_LIBCPP_FUNC_VIS string to_string(unsigned long __val);
        -: 4415:_LIBCPP_FUNC_VIS string to_string(long long __val);
        -: 4416:_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);
        -: 4417:_LIBCPP_FUNC_VIS string to_string(float __val);
        -: 4418:_LIBCPP_FUNC_VIS string to_string(double __val);
        -: 4419:_LIBCPP_FUNC_VIS string to_string(long double __val);
        -: 4420:
        -: 4421:#ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 4422:_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
        -: 4423:_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
        -: 4424:_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
        -: 4425:_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
        -: 4426:_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = nullptr, int __base = 10);
        -: 4427:
        -: 4428:_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = nullptr);
        -: 4429:_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = nullptr);
        -: 4430:_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = nullptr);
        -: 4431:
        -: 4432:_LIBCPP_FUNC_VIS wstring to_wstring(int __val);
        -: 4433:_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);
        -: 4434:_LIBCPP_FUNC_VIS wstring to_wstring(long __val);
        -: 4435:_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);
        -: 4436:_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);
        -: 4437:_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);
        -: 4438:_LIBCPP_FUNC_VIS wstring to_wstring(float __val);
        -: 4439:_LIBCPP_FUNC_VIS wstring to_wstring(double __val);
        -: 4440:_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);
        -: 4441:#endif // _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 4442:
        -: 4443:template<class _CharT, class _Traits, class _Allocator>
        -: 4444:_LIBCPP_TEMPLATE_DATA_VIS
        -: 4445:const typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 4446:               basic_string<_CharT, _Traits, _Allocator>::npos;
        -: 4447:
        -: 4448:template <class _CharT, class _Allocator>
        -: 4449:struct _LIBCPP_TEMPLATE_VIS
        -: 4450:    hash<basic_string<_CharT, char_traits<_CharT>, _Allocator> >
        -: 4451:    : public unary_function<
        -: 4452:          basic_string<_CharT, char_traits<_CharT>, _Allocator>, size_t>
        -: 4453:{
        -: 4454:    size_t
        -: 4455:    operator()(const basic_string<_CharT, char_traits<_CharT>, _Allocator>& __val) const _NOEXCEPT
        -: 4456:    { return __do_string_hash(__val.data(), __val.data() + __val.size()); }
        -: 4457:};
        -: 4458:
        -: 4459:
        -: 4460:template<class _CharT, class _Traits, class _Allocator>
        -: 4461:basic_ostream<_CharT, _Traits>&
        -: 4462:operator<<(basic_ostream<_CharT, _Traits>& __os,
        -: 4463:           const basic_string<_CharT, _Traits, _Allocator>& __str);
        -: 4464:
        -: 4465:template<class _CharT, class _Traits, class _Allocator>
        -: 4466:basic_istream<_CharT, _Traits>&
        -: 4467:operator>>(basic_istream<_CharT, _Traits>& __is,
        -: 4468:           basic_string<_CharT, _Traits, _Allocator>& __str);
        -: 4469:
        -: 4470:template<class _CharT, class _Traits, class _Allocator>
        -: 4471:basic_istream<_CharT, _Traits>&
        -: 4472:getline(basic_istream<_CharT, _Traits>& __is,
        -: 4473:        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);
        -: 4474:
        -: 4475:template<class _CharT, class _Traits, class _Allocator>
        -: 4476:inline _LIBCPP_INLINE_VISIBILITY
        -: 4477:basic_istream<_CharT, _Traits>&
        -: 4478:getline(basic_istream<_CharT, _Traits>& __is,
        -: 4479:        basic_string<_CharT, _Traits, _Allocator>& __str);
        -: 4480:
        -: 4481:template<class _CharT, class _Traits, class _Allocator>
        -: 4482:inline _LIBCPP_INLINE_VISIBILITY
        -: 4483:basic_istream<_CharT, _Traits>&
        -: 4484:getline(basic_istream<_CharT, _Traits>&& __is,
        -: 4485:        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);
        -: 4486:
        -: 4487:template<class _CharT, class _Traits, class _Allocator>
        -: 4488:inline _LIBCPP_INLINE_VISIBILITY
        -: 4489:basic_istream<_CharT, _Traits>&
        -: 4490:getline(basic_istream<_CharT, _Traits>&& __is,
        -: 4491:        basic_string<_CharT, _Traits, _Allocator>& __str);
        -: 4492:
        -: 4493:#if _LIBCPP_STD_VER > 17
        -: 4494:template <class _CharT, class _Traits, class _Allocator, class _Up>
        -: 4495:inline _LIBCPP_INLINE_VISIBILITY
        -: 4496:    typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 4497:    erase(basic_string<_CharT, _Traits, _Allocator>& __str, const _Up& __v) {
        -: 4498:  auto __old_size = __str.size();
        -: 4499:  __str.erase(_VSTD::remove(__str.begin(), __str.end(), __v), __str.end());
        -: 4500:  return __old_size - __str.size();
        -: 4501:}
        -: 4502:
        -: 4503:template <class _CharT, class _Traits, class _Allocator, class _Predicate>
        -: 4504:inline _LIBCPP_INLINE_VISIBILITY
        -: 4505:    typename basic_string<_CharT, _Traits, _Allocator>::size_type
        -: 4506:    erase_if(basic_string<_CharT, _Traits, _Allocator>& __str,
        -: 4507:             _Predicate __pred) {
        -: 4508:  auto __old_size = __str.size();
        -: 4509:  __str.erase(_VSTD::remove_if(__str.begin(), __str.end(), __pred),
        -: 4510:              __str.end());
        -: 4511:  return __old_size - __str.size();
        -: 4512:}
        -: 4513:#endif
        -: 4514:
        -: 4515:#if _LIBCPP_DEBUG_LEVEL == 2
        -: 4516:
        -: 4517:template<class _CharT, class _Traits, class _Allocator>
        -: 4518:bool
        -: 4519:basic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const
        -: 4520:{
        -: 4521:    return this->data() <= _VSTD::__to_address(__i->base()) &&
        -: 4522:           _VSTD::__to_address(__i->base()) < this->data() + this->size();
        -: 4523:}
        -: 4524:
        -: 4525:template<class _CharT, class _Traits, class _Allocator>
        -: 4526:bool
        -: 4527:basic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const
        -: 4528:{
        -: 4529:    return this->data() < _VSTD::__to_address(__i->base()) &&
        -: 4530:           _VSTD::__to_address(__i->base()) <= this->data() + this->size();
        -: 4531:}
        -: 4532:
        -: 4533:template<class _CharT, class _Traits, class _Allocator>
        -: 4534:bool
        -: 4535:basic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const
        -: 4536:{
        -: 4537:    const value_type* __p = _VSTD::__to_address(__i->base()) + __n;
        -: 4538:    return this->data() <= __p && __p <= this->data() + this->size();
        -: 4539:}
        -: 4540:
        -: 4541:template<class _CharT, class _Traits, class _Allocator>
        -: 4542:bool
        -: 4543:basic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const
        -: 4544:{
        -: 4545:    const value_type* __p = _VSTD::__to_address(__i->base()) + __n;
        -: 4546:    return this->data() <= __p && __p < this->data() + this->size();
        -: 4547:}
        -: 4548:
        -: 4549:#endif // _LIBCPP_DEBUG_LEVEL == 2
        -: 4550:
        -: 4551:#if _LIBCPP_STD_VER > 11
        -: 4552:// Literal suffixes for basic_string [basic.string.literals]
        -: 4553:inline namespace literals
        -: 4554:{
        -: 4555:  inline namespace string_literals
        -: 4556:  {
        -: 4557:    inline _LIBCPP_INLINE_VISIBILITY
        -: 4558:    basic_string<char> operator "" s( const char *__str, size_t __len )
        -: 4559:    {
        -: 4560:        return basic_string<char> (__str, __len);
        -: 4561:    }
        -: 4562:
        -: 4563:#ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
        -: 4564:    inline _LIBCPP_INLINE_VISIBILITY
        -: 4565:    basic_string<wchar_t> operator "" s( const wchar_t *__str, size_t __len )
        -: 4566:    {
        -: 4567:        return basic_string<wchar_t> (__str, __len);
        -: 4568:    }
        -: 4569:#endif
        -: 4570:
        -: 4571:#ifndef _LIBCPP_HAS_NO_CHAR8_T
        -: 4572:    inline _LIBCPP_INLINE_VISIBILITY
        -: 4573:    basic_string<char8_t> operator "" s(const char8_t *__str, size_t __len) _NOEXCEPT
        -: 4574:    {
        -: 4575:        return basic_string<char8_t> (__str, __len);
        -: 4576:    }
        -: 4577:#endif
        -: 4578:
        -: 4579:    inline _LIBCPP_INLINE_VISIBILITY
        -: 4580:    basic_string<char16_t> operator "" s( const char16_t *__str, size_t __len )
        -: 4581:    {
        -: 4582:        return basic_string<char16_t> (__str, __len);
        -: 4583:    }
        -: 4584:
        -: 4585:    inline _LIBCPP_INLINE_VISIBILITY
        -: 4586:    basic_string<char32_t> operator "" s( const char32_t *__str, size_t __len )
        -: 4587:    {
        -: 4588:        return basic_string<char32_t> (__str, __len);
        -: 4589:    }
        -: 4590:  }
        -: 4591:}
        -: 4592:#endif
        -: 4593:
        -: 4594:_LIBCPP_END_NAMESPACE_STD
        -: 4595:
        -: 4596:_LIBCPP_POP_MACROS
        -: 4597:
        -: 4598:#endif // _LIBCPP_STRING
