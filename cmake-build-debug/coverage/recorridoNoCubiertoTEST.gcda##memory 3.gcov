        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.3.sdk/usr/include/c++/v1/memory
        -:    0:Graph:/Users/IAGO/Desktop/TPI/cmake-build-debug/CMakeFiles/tpi.dir/testEnunciado/recorridoNoCubiertoTEST.gcno
        -:    0:Data:/Users/IAGO/Desktop/TPI/cmake-build-debug/CMakeFiles/tpi.dir/testEnunciado/recorridoNoCubiertoTEST.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===-------------------------- memory ------------------------------------===//
        -:    3://
        -:    4:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    5:// See https://llvm.org/LICENSE.txt for license information.
        -:    6:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    7://
        -:    8://===----------------------------------------------------------------------===//
        -:    9:
        -:   10:#ifndef _LIBCPP_MEMORY
        -:   11:#define _LIBCPP_MEMORY
        -:   12:
        -:   13:/*
        -:   14:    memory synopsis
        -:   15:
        -:   16:namespace std
        -:   17:{
        -:   18:
        -:   19:struct allocator_arg_t { };
        -:   20:inline constexpr allocator_arg_t allocator_arg = allocator_arg_t();
        -:   21:
        -:   22:template <class T, class Alloc> struct uses_allocator;
        -:   23:
        -:   24:template <class Ptr>
        -:   25:struct pointer_traits
        -:   26:{
        -:   27:    typedef Ptr pointer;
        -:   28:    typedef <details> element_type;
        -:   29:    typedef <details> difference_type;
        -:   30:
        -:   31:    template <class U> using rebind = <details>;
        -:   32:
        -:   33:    static pointer pointer_to(<details>);
        -:   34:};
        -:   35:
        -:   36:template <class T>
        -:   37:struct pointer_traits<T*>
        -:   38:{
        -:   39:    typedef T* pointer;
        -:   40:    typedef T element_type;
        -:   41:    typedef ptrdiff_t difference_type;
        -:   42:
        -:   43:    template <class U> using rebind = U*;
        -:   44:
        -:   45:    static pointer pointer_to(<details>) noexcept; // constexpr in C++20
        -:   46:};
        -:   47:
        -:   48:template <class T> constexpr T* to_address(T* p) noexcept; // C++20
        -:   49:template <class Ptr> constexpr auto to_address(const Ptr& p) noexcept; // C++20
        -:   50:
        -:   51:template <class Alloc>
        -:   52:struct allocator_traits
        -:   53:{
        -:   54:    typedef Alloc                        allocator_type;
        -:   55:    typedef typename allocator_type::value_type
        -:   56:                                         value_type;
        -:   57:
        -:   58:    typedef Alloc::pointer | value_type* pointer;
        -:   59:    typedef Alloc::const_pointer
        -:   60:          | pointer_traits<pointer>::rebind<const value_type>
        -:   61:                                         const_pointer;
        -:   62:    typedef Alloc::void_pointer
        -:   63:          | pointer_traits<pointer>::rebind<void>
        -:   64:                                         void_pointer;
        -:   65:    typedef Alloc::const_void_pointer
        -:   66:          | pointer_traits<pointer>::rebind<const void>
        -:   67:                                         const_void_pointer;
        -:   68:    typedef Alloc::difference_type
        -:   69:          | pointer_traits<pointer>::difference_type
        -:   70:                                         difference_type;
        -:   71:    typedef Alloc::size_type
        -:   72:          | make_unsigned<difference_type>::type
        -:   73:                                         size_type;
        -:   74:    typedef Alloc::propagate_on_container_copy_assignment
        -:   75:          | false_type                   propagate_on_container_copy_assignment;
        -:   76:    typedef Alloc::propagate_on_container_move_assignment
        -:   77:          | false_type                   propagate_on_container_move_assignment;
        -:   78:    typedef Alloc::propagate_on_container_swap
        -:   79:          | false_type                   propagate_on_container_swap;
        -:   80:    typedef Alloc::is_always_equal
        -:   81:          | is_empty                     is_always_equal;
        -:   82:
        -:   83:    template <class T> using rebind_alloc  = Alloc::rebind<T>::other | Alloc<T, Args...>;
        -:   84:    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;
        -:   85:
        -:   86:    static pointer allocate(allocator_type& a, size_type n);                          // constexpr and [[nodiscard]] in C++20
        -:   87:    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint); // constexpr and [[nodiscard]] in C++20
        -:   88:
        -:   89:    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept; // constexpr in C++20
        -:   90:
        -:   91:    template <class T, class... Args>
        -:   92:    static void construct(allocator_type& a, T* p, Args&&... args); // constexpr in C++20
        -:   93:
        -:   94:    template <class T>
        -:   95:    static void destroy(allocator_type& a, T* p); // constexpr in C++20
        -:   96:
        -:   97:    static size_type max_size(const allocator_type& a); // noexcept in C++14, constexpr in C++20
        -:   98:    static allocator_type select_on_container_copy_construction(const allocator_type& a); // constexpr in C++20
        -:   99:};
        -:  100:
        -:  101:template <>
        -:  102:class allocator<void> // removed in C++20
        -:  103:{
        -:  104:public:
        -:  105:    typedef void*                                 pointer;
        -:  106:    typedef const void*                           const_pointer;
        -:  107:    typedef void                                  value_type;
        -:  108:
        -:  109:    template <class _Up> struct rebind {typedef allocator<_Up> other;};
        -:  110:};
        -:  111:
        -:  112:template <class T>
        -:  113:class allocator
        -:  114:{
        -:  115:public:
        -:  116:    typedef size_t    size_type;
        -:  117:    typedef ptrdiff_t difference_type;
        -:  118:    typedef T*        pointer;                           // deprecated in C++17, removed in C++20
        -:  119:    typedef const T*  const_pointer;                     // deprecated in C++17, removed in C++20
        -:  120:    typedef typename add_lvalue_reference<T>::type
        -:  121:                      reference;                         // deprecated in C++17, removed in C++20
        -:  122:    typedef typename add_lvalue_reference<const T>::type
        -:  123:                      const_reference;                   // deprecated in C++17, removed in C++20
        -:  124:
        -:  125:    typedef T         value_type;
        -:  126:
        -:  127:    template <class U> struct rebind {typedef allocator<U> other;}; // deprecated in C++17, removed in C++20
        -:  128:
        -:  129:    typedef true_type propagate_on_container_move_assignment;
        -:  130:    typedef true_type is_always_equal;
        -:  131:
        -:  132:    constexpr allocator() noexcept;                      // constexpr in C++20
        -:  133:    constexpr allocator(const allocator&) noexcept;      // constexpr in C++20
        -:  134:    template <class U>
        -:  135:      constexpr allocator(const allocator<U>&) noexcept; // constexpr in C++20
        -:  136:    ~allocator();                                        // constexpr in C++20
        -:  137:    pointer address(reference x) const noexcept;             // deprecated in C++17, removed in C++20
        -:  138:    const_pointer address(const_reference x) const noexcept; // deprecated in C++17, removed in C++20
        -:  139:    T* allocate(size_t n, const void* hint);          // deprecated in C++17, removed in C++20
        -:  140:    T* allocate(size_t n);                              // constexpr in C++20
        -:  141:    void deallocate(T* p, size_t n) noexcept;           // constexpr in C++20
        -:  142:    size_type max_size() const noexcept;              // deprecated in C++17, removed in C++20
        -:  143:    template<class U, class... Args>
        -:  144:        void construct(U* p, Args&&... args);         // deprecated in C++17, removed in C++20
        -:  145:    template <class U>
        -:  146:        void destroy(U* p);                           // deprecated in C++17, removed in C++20
        -:  147:};
        -:  148:
        -:  149:template <class T, class U>
        -:  150:bool operator==(const allocator<T>&, const allocator<U>&) noexcept; // constexpr in C++20
        -:  151:
        -:  152:template <class T, class U>
        -:  153:bool operator!=(const allocator<T>&, const allocator<U>&) noexcept; // constexpr in C++20
        -:  154:
        -:  155:template <class OutputIterator, class T>
        -:  156:class raw_storage_iterator // deprecated in C++17, removed in C++20
        -:  157:    : public iterator<output_iterator_tag, void, void, void, void> // until C++17
        -:  158:{
        -:  159:public:
        -:  160:    typedef output_iterator_tag iterator_category;
        -:  161:    typedef void                value_type;
        -:  162:    typedef void                difference_type; // until C++20
        -:  163:    typedef ptrdiff_t           difference_type; // since C++20
        -:  164:    typedef void                pointer;
        -:  165:    typedef void                reference;
        -:  166:
        -:  167:    explicit raw_storage_iterator(OutputIterator x);
        -:  168:    raw_storage_iterator& operator*();
        -:  169:    raw_storage_iterator& operator=(const T& element);
        -:  170:    raw_storage_iterator& operator++();
        -:  171:    raw_storage_iterator  operator++(int);
        -:  172:};
        -:  173:
        -:  174:template <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;
        -:  175:template <class T> void               return_temporary_buffer(T* p) noexcept;
        -:  176:
        -:  177:template <class T> T* addressof(T& r) noexcept;
        -:  178:template <class T> T* addressof(const T&& r) noexcept = delete;
        -:  179:
        -:  180:template <class InputIterator, class ForwardIterator>
        -:  181:ForwardIterator
        -:  182:uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);
        -:  183:
        -:  184:template <class InputIterator, class Size, class ForwardIterator>
        -:  185:ForwardIterator
        -:  186:uninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);
        -:  187:
        -:  188:template <class ForwardIterator, class T>
        -:  189:void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);
        -:  190:
        -:  191:template <class ForwardIterator, class Size, class T>
        -:  192:ForwardIterator
        -:  193:uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
        -:  194:
        -:  195:template <class T, class ...Args>
        -:  196:constexpr T* construct_at(T* location, Args&& ...args); // since C++20
        -:  197:
        -:  198:template <class T>
        -:  199:void destroy_at(T* location); // constexpr in C++20
        -:  200:
        -:  201:template <class ForwardIterator>
        -:  202:void destroy(ForwardIterator first, ForwardIterator last); // constexpr in C++20
        -:  203:
        -:  204:template <class ForwardIterator, class Size>
        -:  205:ForwardIterator destroy_n(ForwardIterator first, Size n); // constexpr in C++20
        -:  206:
        -:  207:template <class InputIterator, class ForwardIterator>
        -:  208: ForwardIterator uninitialized_move(InputIterator first, InputIterator last, ForwardIterator result);
        -:  209:
        -:  210:template <class InputIterator, class Size, class ForwardIterator>
        -:  211: pair<InputIterator,ForwardIterator> uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);
        -:  212:
        -:  213:template <class ForwardIterator>
        -:  214: void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);
        -:  215:
        -:  216:template <class ForwardIterator, class Size>
        -:  217: ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);
        -:  218:
        -:  219:template <class ForwardIterator>
        -:  220: void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);
        -:  221:
        -:  222:template <class ForwardIterator, class Size>
        -:  223: ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);
        -:  224:
        -:  225:template <class Y> struct auto_ptr_ref {};      // deprecated in C++11, removed in C++17
        -:  226:
        -:  227:template<class X>
        -:  228:class auto_ptr                                  // deprecated in C++11, removed in C++17
        -:  229:{
        -:  230:public:
        -:  231:    typedef X element_type;
        -:  232:
        -:  233:    explicit auto_ptr(X* p =0) throw();
        -:  234:    auto_ptr(auto_ptr&) throw();
        -:  235:    template<class Y> auto_ptr(auto_ptr<Y>&) throw();
        -:  236:    auto_ptr& operator=(auto_ptr&) throw();
        -:  237:    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();
        -:  238:    auto_ptr& operator=(auto_ptr_ref<X> r) throw();
        -:  239:    ~auto_ptr() throw();
        -:  240:
        -:  241:    typename add_lvalue_reference<X>::type operator*() const throw();
        -:  242:    X* operator->() const throw();
        -:  243:    X* get() const throw();
        -:  244:    X* release() throw();
        -:  245:    void reset(X* p =0) throw();
        -:  246:
        -:  247:    auto_ptr(auto_ptr_ref<X>) throw();
        -:  248:    template<class Y> operator auto_ptr_ref<Y>() throw();
        -:  249:    template<class Y> operator auto_ptr<Y>() throw();
        -:  250:};
        -:  251:
        -:  252:template <class T>
        -:  253:struct default_delete
        -:  254:{
        -:  255:    constexpr default_delete() noexcept = default;
        -:  256:    template <class U> default_delete(const default_delete<U>&) noexcept;
        -:  257:
        -:  258:    void operator()(T*) const noexcept;
        -:  259:};
        -:  260:
        -:  261:template <class T>
        -:  262:struct default_delete<T[]>
        -:  263:{
        -:  264:    constexpr default_delete() noexcept = default;
        -:  265:    void operator()(T*) const noexcept;
        -:  266:    template <class U> void operator()(U*) const = delete;
        -:  267:};
        -:  268:
        -:  269:template <class T, class D = default_delete<T>>
        -:  270:class unique_ptr
        -:  271:{
        -:  272:public:
        -:  273:    typedef see below pointer;
        -:  274:    typedef T element_type;
        -:  275:    typedef D deleter_type;
        -:  276:
        -:  277:    // constructors
        -:  278:    constexpr unique_ptr() noexcept;
        -:  279:    explicit unique_ptr(pointer p) noexcept;
        -:  280:    unique_ptr(pointer p, see below d1) noexcept;
        -:  281:    unique_ptr(pointer p, see below d2) noexcept;
        -:  282:    unique_ptr(unique_ptr&& u) noexcept;
        -:  283:    unique_ptr(nullptr_t) noexcept : unique_ptr() { }
        -:  284:    template <class U, class E>
        -:  285:        unique_ptr(unique_ptr<U, E>&& u) noexcept;
        -:  286:    template <class U>
        -:  287:        unique_ptr(auto_ptr<U>&& u) noexcept;       // removed in C++17
        -:  288:
        -:  289:    // destructor
        -:  290:    ~unique_ptr();
        -:  291:
        -:  292:    // assignment
        -:  293:    unique_ptr& operator=(unique_ptr&& u) noexcept;
        -:  294:    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
        -:  295:    unique_ptr& operator=(nullptr_t) noexcept;
        -:  296:
        -:  297:    // observers
        -:  298:    typename add_lvalue_reference<T>::type operator*() const;
        -:  299:    pointer operator->() const noexcept;
        -:  300:    pointer get() const noexcept;
        -:  301:    deleter_type& get_deleter() noexcept;
        -:  302:    const deleter_type& get_deleter() const noexcept;
        -:  303:    explicit operator bool() const noexcept;
        -:  304:
        -:  305:    // modifiers
        -:  306:    pointer release() noexcept;
        -:  307:    void reset(pointer p = pointer()) noexcept;
        -:  308:    void swap(unique_ptr& u) noexcept;
        -:  309:};
        -:  310:
        -:  311:template <class T, class D>
        -:  312:class unique_ptr<T[], D>
        -:  313:{
        -:  314:public:
        -:  315:    typedef implementation-defined pointer;
        -:  316:    typedef T element_type;
        -:  317:    typedef D deleter_type;
        -:  318:
        -:  319:    // constructors
        -:  320:    constexpr unique_ptr() noexcept;
        -:  321:    explicit unique_ptr(pointer p) noexcept;
        -:  322:    unique_ptr(pointer p, see below d) noexcept;
        -:  323:    unique_ptr(pointer p, see below d) noexcept;
        -:  324:    unique_ptr(unique_ptr&& u) noexcept;
        -:  325:    unique_ptr(nullptr_t) noexcept : unique_ptr() { }
        -:  326:
        -:  327:    // destructor
        -:  328:    ~unique_ptr();
        -:  329:
        -:  330:    // assignment
        -:  331:    unique_ptr& operator=(unique_ptr&& u) noexcept;
        -:  332:    unique_ptr& operator=(nullptr_t) noexcept;
        -:  333:
        -:  334:    // observers
        -:  335:    T& operator[](size_t i) const;
        -:  336:    pointer get() const noexcept;
        -:  337:    deleter_type& get_deleter() noexcept;
        -:  338:    const deleter_type& get_deleter() const noexcept;
        -:  339:    explicit operator bool() const noexcept;
        -:  340:
        -:  341:    // modifiers
        -:  342:    pointer release() noexcept;
        -:  343:    void reset(pointer p = pointer()) noexcept;
        -:  344:    void reset(nullptr_t) noexcept;
        -:  345:  template <class U> void reset(U) = delete;
        -:  346:    void swap(unique_ptr& u) noexcept;
        -:  347:};
        -:  348:
        -:  349:template <class T, class D>
        -:  350:    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;
        -:  351:
        -:  352:template <class T1, class D1, class T2, class D2>
        -:  353:    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
        -:  354:template <class T1, class D1, class T2, class D2>
        -:  355:    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
        -:  356:template <class T1, class D1, class T2, class D2>
        -:  357:    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
        -:  358:template <class T1, class D1, class T2, class D2>
        -:  359:    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
        -:  360:template <class T1, class D1, class T2, class D2>
        -:  361:    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
        -:  362:template <class T1, class D1, class T2, class D2>
        -:  363:    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
        -:  364:
        -:  365:template <class T, class D>
        -:  366:    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;
        -:  367:template <class T, class D>
        -:  368:    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;
        -:  369:template <class T, class D>
        -:  370:    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;
        -:  371:template <class T, class D>
        -:  372:    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;
        -:  373:
        -:  374:template <class T, class D>
        -:  375:    bool operator<(const unique_ptr<T, D>& x, nullptr_t);
        -:  376:template <class T, class D>
        -:  377:    bool operator<(nullptr_t, const unique_ptr<T, D>& y);
        -:  378:template <class T, class D>
        -:  379:    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);
        -:  380:template <class T, class D>
        -:  381:    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);
        -:  382:template <class T, class D>
        -:  383:    bool operator>(const unique_ptr<T, D>& x, nullptr_t);
        -:  384:template <class T, class D>
        -:  385:    bool operator>(nullptr_t, const unique_ptr<T, D>& y);
        -:  386:template <class T, class D>
        -:  387:    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);
        -:  388:template <class T, class D>
        -:  389:    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);
        -:  390:
        -:  391:class bad_weak_ptr
        -:  392:    : public std::exception
        -:  393:{
        -:  394:    bad_weak_ptr() noexcept;
        -:  395:};
        -:  396:
        -:  397:template<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14
        -:  398:template<class T>                unique_ptr<T> make_unique(size_t n);           // C++14
        -:  399:template<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]
        -:  400:
        -:  401:template<class E, class T, class Y, class D>
        -:  402:    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, unique_ptr<Y, D> const& p);
        -:  403:
        -:  404:template<class T>
        -:  405:class shared_ptr
        -:  406:{
        -:  407:public:
        -:  408:    typedef T element_type;
        -:  409:    typedef weak_ptr<T> weak_type; // C++17
        -:  410:
        -:  411:    // constructors:
        -:  412:    constexpr shared_ptr() noexcept;
        -:  413:    template<class Y> explicit shared_ptr(Y* p);
        -:  414:    template<class Y, class D> shared_ptr(Y* p, D d);
        -:  415:    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);
        -:  416:    template <class D> shared_ptr(nullptr_t p, D d);
        -:  417:    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);
        -:  418:    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;
        -:  419:    shared_ptr(const shared_ptr& r) noexcept;
        -:  420:    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;
        -:  421:    shared_ptr(shared_ptr&& r) noexcept;
        -:  422:    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;
        -:  423:    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);
        -:  424:    template<class Y> shared_ptr(auto_ptr<Y>&& r);          // removed in C++17
        -:  425:    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);
        -:  426:    shared_ptr(nullptr_t) : shared_ptr() { }
        -:  427:
        -:  428:    // destructor:
        -:  429:    ~shared_ptr();
        -:  430:
        -:  431:    // assignment:
        -:  432:    shared_ptr& operator=(const shared_ptr& r) noexcept;
        -:  433:    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
        -:  434:    shared_ptr& operator=(shared_ptr&& r) noexcept;
        -:  435:    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);
        -:  436:    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r); // removed in C++17
        -:  437:    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);
        -:  438:
        -:  439:    // modifiers:
        -:  440:    void swap(shared_ptr& r) noexcept;
        -:  441:    void reset() noexcept;
        -:  442:    template<class Y> void reset(Y* p);
        -:  443:    template<class Y, class D> void reset(Y* p, D d);
        -:  444:    template<class Y, class D, class A> void reset(Y* p, D d, A a);
        -:  445:
        -:  446:    // observers:
        -:  447:    T* get() const noexcept;
        -:  448:    T& operator*() const noexcept;
        -:  449:    T* operator->() const noexcept;
        -:  450:    long use_count() const noexcept;
        -:  451:    bool unique() const noexcept;
        -:  452:    explicit operator bool() const noexcept;
        -:  453:    template<class U> bool owner_before(shared_ptr<U> const& b) const noexcept;
        -:  454:    template<class U> bool owner_before(weak_ptr<U> const& b) const noexcept;
        -:  455:};
        -:  456:
        -:  457:template<class T>
        -:  458:shared_ptr(weak_ptr<T>) -> shared_ptr<T>;
        -:  459:template<class T, class D>
        -:  460:shared_ptr(unique_ptr<T, D>) -> shared_ptr<T>;
        -:  461:
        -:  462:// shared_ptr comparisons:
        -:  463:template<class T, class U>
        -:  464:    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
        -:  465:template<class T, class U>
        -:  466:    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
        -:  467:template<class T, class U>
        -:  468:    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
        -:  469:template<class T, class U>
        -:  470:    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
        -:  471:template<class T, class U>
        -:  472:    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
        -:  473:template<class T, class U>
        -:  474:    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
        -:  475:
        -:  476:template <class T>
        -:  477:    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;
        -:  478:template <class T>
        -:  479:    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;
        -:  480:template <class T>
        -:  481:    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;
        -:  482:template <class T>
        -:  483:    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;
        -:  484:template <class T>
        -:  485:    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;
        -:  486:template <class T>
        -:  487:bool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;
        -:  488:template <class T>
        -:  489:    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;
        -:  490:template <class T>
        -:  491:    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;
        -:  492:template <class T>
        -:  493:    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;
        -:  494:template <class T>
        -:  495:    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;
        -:  496:template <class T>
        -:  497:    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;
        -:  498:template <class T>
        -:  499:    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;
        -:  500:
        -:  501:// shared_ptr specialized algorithms:
        -:  502:template<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;
        -:  503:
        -:  504:// shared_ptr casts:
        -:  505:template<class T, class U>
        -:  506:    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;
        -:  507:template<class T, class U>
        -:  508:    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;
        -:  509:template<class T, class U>
        -:  510:    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;
        -:  511:
        -:  512:// shared_ptr I/O:
        -:  513:template<class E, class T, class Y>
        -:  514:    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);
        -:  515:
        -:  516:// shared_ptr get_deleter:
        -:  517:template<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;
        -:  518:
        -:  519:template<class T, class... Args>
        -:  520:    shared_ptr<T> make_shared(Args&&... args);
        -:  521:template<class T, class A, class... Args>
        -:  522:    shared_ptr<T> allocate_shared(const A& a, Args&&... args);
        -:  523:
        -:  524:template<class T>
        -:  525:class weak_ptr
        -:  526:{
        -:  527:public:
        -:  528:    typedef T element_type;
        -:  529:
        -:  530:    // constructors
        -:  531:    constexpr weak_ptr() noexcept;
        -:  532:    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;
        -:  533:    weak_ptr(weak_ptr const& r) noexcept;
        -:  534:    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;
        -:  535:    weak_ptr(weak_ptr&& r) noexcept;                      // C++14
        -:  536:    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14
        -:  537:
        -:  538:    // destructor
        -:  539:    ~weak_ptr();
        -:  540:
        -:  541:    // assignment
        -:  542:    weak_ptr& operator=(weak_ptr const& r) noexcept;
        -:  543:    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;
        -:  544:    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;
        -:  545:    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14
        -:  546:    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14
        -:  547:
        -:  548:    // modifiers
        -:  549:    void swap(weak_ptr& r) noexcept;
        -:  550:    void reset() noexcept;
        -:  551:
        -:  552:    // observers
        -:  553:    long use_count() const noexcept;
        -:  554:    bool expired() const noexcept;
        -:  555:    shared_ptr<T> lock() const noexcept;
        -:  556:    template<class U> bool owner_before(shared_ptr<U> const& b) const noexcept;
        -:  557:    template<class U> bool owner_before(weak_ptr<U> const& b) const noexcept;
        -:  558:};
        -:  559:
        -:  560:template<class T>
        -:  561:weak_ptr(shared_ptr<T>) -> weak_ptr<T>;
        -:  562:
        -:  563:// weak_ptr specialized algorithms:
        -:  564:template<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
        -:  565:
        -:  566:// class owner_less:
        -:  567:template<class T> struct owner_less;
        -:  568:
        -:  569:template<class T>
        -:  570:struct owner_less<shared_ptr<T> >
        -:  571:    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>
        -:  572:{
        -:  573:    typedef bool result_type;
        -:  574:    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const noexcept;
        -:  575:    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const noexcept;
        -:  576:    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const noexcept;
        -:  577:};
        -:  578:
        -:  579:template<class T>
        -:  580:struct owner_less<weak_ptr<T> >
        -:  581:    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>
        -:  582:{
        -:  583:    typedef bool result_type;
        -:  584:    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const noexcept;
        -:  585:    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const noexcept;
        -:  586:    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const noexcept;
        -:  587:};
        -:  588:
        -:  589:template <>  // Added in C++14
        -:  590:struct owner_less<void>
        -:  591:{
        -:  592:    template <class _Tp, class _Up>
        -:  593:    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept;
        -:  594:    template <class _Tp, class _Up>
        -:  595:    bool operator()( shared_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const noexcept;
        -:  596:    template <class _Tp, class _Up>
        -:  597:    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept;
        -:  598:    template <class _Tp, class _Up>
        -:  599:    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const noexcept;
        -:  600:
        -:  601:    typedef void is_transparent;
        -:  602:};
        -:  603:
        -:  604:template<class T>
        -:  605:class enable_shared_from_this
        -:  606:{
        -:  607:protected:
        -:  608:    constexpr enable_shared_from_this() noexcept;
        -:  609:    enable_shared_from_this(enable_shared_from_this const&) noexcept;
        -:  610:    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;
        -:  611:    ~enable_shared_from_this();
        -:  612:public:
        -:  613:    shared_ptr<T> shared_from_this();
        -:  614:    shared_ptr<T const> shared_from_this() const;
        -:  615:};
        -:  616:
        -:  617:template<class T>
        -:  618:    bool atomic_is_lock_free(const shared_ptr<T>* p);
        -:  619:template<class T>
        -:  620:    shared_ptr<T> atomic_load(const shared_ptr<T>* p);
        -:  621:template<class T>
        -:  622:    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);
        -:  623:template<class T>
        -:  624:    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);
        -:  625:template<class T>
        -:  626:    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);
        -:  627:template<class T>
        -:  628:    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);
        -:  629:template<class T>
        -:  630:    shared_ptr<T>
        -:  631:    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);
        -:  632:template<class T>
        -:  633:    bool
        -:  634:    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
        -:  635:template<class T>
        -:  636:    bool
        -:  637:    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
        -:  638:template<class T>
        -:  639:    bool
        -:  640:    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,
        -:  641:                                          shared_ptr<T> w, memory_order success,
        -:  642:                                          memory_order failure);
        -:  643:template<class T>
        -:  644:    bool
        -:  645:    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,
        -:  646:                                            shared_ptr<T> w, memory_order success,
        -:  647:                                            memory_order failure);
        -:  648:// Hash support
        -:  649:template <class T> struct hash;
        -:  650:template <class T, class D> struct hash<unique_ptr<T, D> >;
        -:  651:template <class T> struct hash<shared_ptr<T> >;
        -:  652:
        -:  653:template <class T, class Alloc>
        -:  654:  inline constexpr bool uses_allocator_v = uses_allocator<T, Alloc>::value;
        -:  655:
        -:  656:// Pointer safety
        -:  657:enum class pointer_safety { relaxed, preferred, strict }; // since C++11
        -:  658:void declare_reachable(void *p);                          // since C++11
        -:  659:template <class T> T *undeclare_reachable(T *p);          // since C++11
        -:  660:void declare_no_pointers(char *p, size_t n);              // since C++11
        -:  661:void undeclare_no_pointers(char *p, size_t n);            // since C++11
        -:  662:pointer_safety get_pointer_safety() noexcept;             // since C++11
        -:  663:
        -:  664:void* align(size_t alignment, size_t size, void*& ptr, size_t& space);
        -:  665:
        -:  666:}  // std
        -:  667:
        -:  668:*/
        -:  669:
        -:  670:#include <__config>
        -:  671:#include <__functional_base>
        -:  672:#include <__memory/addressof.h>
        -:  673:#include <__memory/allocation_guard.h>
        -:  674:#include <__memory/allocator.h>
        -:  675:#include <__memory/allocator_arg_t.h>
        -:  676:#include <__memory/allocator_traits.h>
        -:  677:#include <__memory/compressed_pair.h>
        -:  678:#include <__memory/construct_at.h>
        -:  679:#include <__memory/pointer_safety.h>
        -:  680:#include <__memory/pointer_traits.h>
        -:  681:#include <__memory/raw_storage_iterator.h>
        -:  682:#include <__memory/shared_ptr.h>
        -:  683:#include <__memory/temporary_buffer.h>
        -:  684:#include <__memory/uninitialized_algorithms.h>
        -:  685:#include <__memory/unique_ptr.h>
        -:  686:#include <__memory/uses_allocator.h>
        -:  687:#include <compare>
        -:  688:#include <cstddef>
        -:  689:#include <cstdint>
        -:  690:#include <cstring>
        -:  691:#include <iosfwd>
        -:  692:#include <iterator>
        -:  693:#include <new>
        -:  694:#include <stdexcept>
        -:  695:#include <tuple>
        -:  696:#include <type_traits>
        -:  697:#include <typeinfo>
        -:  698:#include <utility>
        -:  699:#include <version>
        -:  700:
        -:  701:#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
        -:  702:#   include <__memory/auto_ptr.h>
        -:  703:#endif
        -:  704:
        -:  705:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  706:#pragma GCC system_header
        -:  707:#endif
        -:  708:
        -:  709:_LIBCPP_PUSH_MACROS
        -:  710:#include <__undef_macros>
        -:  711:
        -:  712:
        -:  713:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  714:
        -:  715:template <class _Alloc, class _Ptr>
        -:  716:_LIBCPP_INLINE_VISIBILITY
        -:  717:void __construct_forward_with_exception_guarantees(_Alloc& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2) {
        -:  718:    static_assert(__is_cpp17_move_insertable<_Alloc>::value,
        -:  719:        "The specified type does not meet the requirements of Cpp17MoveInsertable");
        -:  720:    typedef allocator_traits<_Alloc> _Traits;
        -:  721:    for (; __begin1 != __end1; ++__begin1, (void)++__begin2) {
        -:  722:        _Traits::construct(__a, _VSTD::__to_address(__begin2),
        -:  723:#ifdef _LIBCPP_NO_EXCEPTIONS
        -:  724:            _VSTD::move(*__begin1)
        -:  725:#else
        -:  726:            _VSTD::move_if_noexcept(*__begin1)
        -:  727:#endif
        -:  728:        );
        -:  729:    }
        -:  730:}
        -:  731:
        -:  732:template <class _Alloc, class _Tp, typename enable_if<
        -:  733:    (__is_default_allocator<_Alloc>::value || !__has_construct<_Alloc, _Tp*, _Tp>::value) &&
        -:  734:    is_trivially_move_constructible<_Tp>::value
        -:  735:>::type>
        -:  736:_LIBCPP_INLINE_VISIBILITY
        -:  737:void __construct_forward_with_exception_guarantees(_Alloc&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2) {
        -:  738:    ptrdiff_t _Np = __end1 - __begin1;
        -:  739:    if (_Np > 0) {
        -:  740:        _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
        -:  741:        __begin2 += _Np;
        -:  742:    }
        -:  743:}
        -:  744:
        -:  745:template <class _Alloc, class _Iter, class _Ptr>
        -:  746:_LIBCPP_INLINE_VISIBILITY
        -:  747:void __construct_range_forward(_Alloc& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2) {
        -:  748:    typedef allocator_traits<_Alloc> _Traits;
        -:  749:    for (; __begin1 != __end1; ++__begin1, (void) ++__begin2) {
        -:  750:        _Traits::construct(__a, _VSTD::__to_address(__begin2), *__begin1);
        -:  751:    }
        -:  752:}
        -:  753:
        -:  754:template <class _Alloc, class _Source, class _Dest,
        -:  755:          class _RawSource = typename remove_const<_Source>::type,
        -:  756:          class _RawDest = typename remove_const<_Dest>::type,
        -:  757:          class =
        -:  758:    typename enable_if<
        -:  759:        is_trivially_copy_constructible<_Dest>::value &&
        -:  760:        is_same<_RawSource, _RawDest>::value &&
        -:  761:        (__is_default_allocator<_Alloc>::value || !__has_construct<_Alloc, _Dest*, _Source&>::value)
        -:  762:    >::type>
        -:  763:_LIBCPP_INLINE_VISIBILITY
function _ZNSt3__1L25__construct_range_forwardINS_9allocatorINS_5tupleIJddEEEEEKS3_S3_S3_S3_vEEvRT_PT0_S9_RPT1_ called 3 returned 100% blocks executed 100%
function _ZNSt3__1L25__construct_range_forwardINS_9allocatorINS_5tupleIJdNS2_IJddEEEEEEEES4_S4_S4_S4_vEEvRT_PT0_S9_RPT1_ called 0 returned 0% blocks executed 0%
function _ZNSt3__1L25__construct_range_forwardINS_9allocatorINS_5tupleIJddEEEEES3_S3_S3_S3_vEEvRT_PT0_S8_RPT1_ called 2 returned 100% blocks executed 100%
        5:  764:void __construct_range_forward(_Alloc&, _Source* __begin1, _Source* __end1, _Dest*& __begin2) {
        5:  765:    ptrdiff_t _Np = __end1 - __begin1;
        5:  766:    if (_Np > 0) {
        3:  766-block  0
branch  0 taken 3
branch  1 taken 0
    $$$$$:  766-block  1
branch  2 never executed
branch  3 never executed
        2:  766-block  2
branch  4 taken 2
branch  5 taken 0
        5:  767:        _VSTD::memcpy(const_cast<_RawDest*>(__begin2), __begin1, _Np * sizeof(_Dest));
        5:  768:        __begin2 += _Np;
        5:  769:    }
        3:  769-block  0
    $$$$$:  769-block  1
        2:  769-block  2
        5:  770:}
        3:  770-block  0
    $$$$$:  770-block  1
        2:  770-block  2
        -:  771:
        -:  772:template <class _Alloc, class _Ptr>
        -:  773:_LIBCPP_INLINE_VISIBILITY
        -:  774:void __construct_backward_with_exception_guarantees(_Alloc& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2) {
        -:  775:    static_assert(__is_cpp17_move_insertable<_Alloc>::value,
        -:  776:        "The specified type does not meet the requirements of Cpp17MoveInsertable");
        -:  777:    typedef allocator_traits<_Alloc> _Traits;
        -:  778:    while (__end1 != __begin1) {
        -:  779:        _Traits::construct(__a, _VSTD::__to_address(__end2 - 1),
        -:  780:#ifdef _LIBCPP_NO_EXCEPTIONS
        -:  781:            _VSTD::move(*--__end1)
        -:  782:#else
        -:  783:            _VSTD::move_if_noexcept(*--__end1)
        -:  784:#endif
        -:  785:        );
        -:  786:        --__end2;
        -:  787:    }
        -:  788:}
        -:  789:
        -:  790:template <class _Alloc, class _Tp, class = typename enable_if<
        -:  791:    (__is_default_allocator<_Alloc>::value || !__has_construct<_Alloc, _Tp*, _Tp>::value) &&
        -:  792:    is_trivially_move_constructible<_Tp>::value
        -:  793:>::type>
        -:  794:_LIBCPP_INLINE_VISIBILITY
function _ZNSt3__1L46__construct_backward_with_exception_guaranteesINS_9allocatorINS_5tupleIJdNS2_IJddEEEEEEEES4_vEEvRT_PT0_S9_RS9_ called 10 returned 100% blocks executed 100%
       10:  795:void __construct_backward_with_exception_guarantees(_Alloc&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2) {
       10:  796:    ptrdiff_t _Np = __end1 - __begin1;
       10:  797:    __end2 -= _Np;
       10:  798:    if (_Np > 0)
       10:  798-block  0
branch  0 taken 8
branch  1 taken 2
        8:  799:        _VSTD::memcpy(static_cast<void*>(__end2), static_cast<void const*>(__begin1), _Np * sizeof(_Tp));
        8:  799-block  0
       10:  800:}
       10:  800-block  0
        -:  801:
        -:  802:struct __destruct_n
        -:  803:{
        -:  804:private:
        -:  805:    size_t __size_;
        -:  806:
        -:  807:    template <class _Tp>
        -:  808:    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT
        -:  809:        {for (size_t __i = 0; __i < __size_; ++__i, ++__p) __p->~_Tp();}
        -:  810:
        -:  811:    template <class _Tp>
        -:  812:    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT
        -:  813:        {}
        -:  814:
        -:  815:    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT
        -:  816:        {++__size_;}
        -:  817:    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT
        -:  818:        {}
        -:  819:
        -:  820:    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT
        -:  821:        {__size_ = __s;}
        -:  822:    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT
        -:  823:        {}
        -:  824:public:
        -:  825:    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT
        -:  826:        : __size_(__s) {}
        -:  827:
        -:  828:    template <class _Tp>
        -:  829:    _LIBCPP_INLINE_VISIBILITY void __incr() _NOEXCEPT
        -:  830:        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
        -:  831:
        -:  832:    template <class _Tp>
        -:  833:    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT
        -:  834:        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
        -:  835:
        -:  836:    template <class _Tp>
        -:  837:    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT
        -:  838:        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
        -:  839:};
        -:  840:
        -:  841:_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);
        -:  842:
        -:  843:// --- Helper for container swap --
        -:  844:template <typename _Alloc>
        -:  845:_LIBCPP_INLINE_VISIBILITY
        -:  846:void __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)
        -:  847:#if _LIBCPP_STD_VER >= 14
        -:  848:    _NOEXCEPT
        -:  849:#else
        -:  850:    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)
        -:  851:#endif
        -:  852:{
        -:  853:    using _VSTD::swap;
        -:  854:    swap(__a1, __a2);
        -:  855:}
        -:  856:
        -:  857:template <typename _Alloc>
        -:  858:inline _LIBCPP_INLINE_VISIBILITY
        -:  859:void __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {}
        -:  860:
        -:  861:template <typename _Alloc>
        -:  862:inline _LIBCPP_INLINE_VISIBILITY
        -:  863:void __swap_allocator(_Alloc & __a1, _Alloc & __a2)
        -:  864:#if _LIBCPP_STD_VER >= 14
        -:  865:    _NOEXCEPT
        -:  866:#else
        -:  867:    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)
        -:  868:#endif
        -:  869:{
        -:  870:    _VSTD::__swap_allocator(__a1, __a2,
        -:  871:      integral_constant<bool, allocator_traits<_Alloc>::propagate_on_container_swap::value>());
        -:  872:}
        -:  873:
        -:  874:template <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >
        -:  875:struct __noexcept_move_assign_container : public integral_constant<bool,
        -:  876:    _Traits::propagate_on_container_move_assignment::value
        -:  877:#if _LIBCPP_STD_VER > 14
        -:  878:        || _Traits::is_always_equal::value
        -:  879:#else
        -:  880:        && is_nothrow_move_assignable<_Alloc>::value
        -:  881:#endif
        -:  882:    > {};
        -:  883:
        -:  884:
        -:  885:template <class _Tp, class _Alloc>
        -:  886:struct __temp_value {
        -:  887:    typedef allocator_traits<_Alloc> _Traits;
        -:  888:
        -:  889:    typename aligned_storage<sizeof(_Tp), _LIBCPP_ALIGNOF(_Tp)>::type __v;
        -:  890:    _Alloc &__a;
        -:  891:
        -:  892:    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }
        -:  893:    _Tp &   get() { return *__addr(); }
        -:  894:
        -:  895:    template<class... _Args>
        -:  896:    _LIBCPP_NO_CFI
        -:  897:    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc) {
        -:  898:      _Traits::construct(__a, reinterpret_cast<_Tp*>(addressof(__v)),
        -:  899:                         _VSTD::forward<_Args>(__args)...);
        -:  900:    }
        -:  901:
        -:  902:    ~__temp_value() { _Traits::destroy(__a, __addr()); }
        -:  903:    };
        -:  904:
        -:  905:template<typename _Alloc, typename = void, typename = void>
        -:  906:struct __is_allocator : false_type {};
        -:  907:
        -:  908:template<typename _Alloc>
        -:  909:struct __is_allocator<_Alloc,
        -:  910:       typename __void_t<typename _Alloc::value_type>::type,
        -:  911:       typename __void_t<decltype(declval<_Alloc&>().allocate(size_t(0)))>::type
        -:  912:     >
        -:  913:   : true_type {};
        -:  914:
        -:  915:// __builtin_new_allocator -- A non-templated helper for allocating and
        -:  916:// deallocating memory using __builtin_operator_new and
        -:  917:// __builtin_operator_delete. It should be used in preference to
        -:  918:// `std::allocator<T>` to avoid additional instantiations.
        -:  919:struct __builtin_new_allocator {
        -:  920:  struct __builtin_new_deleter {
        -:  921:    typedef void* pointer_type;
        -:  922:
        -:  923:    _LIBCPP_CONSTEXPR explicit __builtin_new_deleter(size_t __size, size_t __align)
        -:  924:        : __size_(__size), __align_(__align) {}
        -:  925:
        -:  926:    void operator()(void* p) const _NOEXCEPT {
        -:  927:        _VSTD::__libcpp_deallocate(p, __size_, __align_);
        -:  928:    }
        -:  929:
        -:  930:   private:
        -:  931:    size_t __size_;
        -:  932:    size_t __align_;
        -:  933:  };
        -:  934:
        -:  935:  typedef unique_ptr<void, __builtin_new_deleter> __holder_t;
        -:  936:
        -:  937:  static __holder_t __allocate_bytes(size_t __s, size_t __align) {
        -:  938:      return __holder_t(_VSTD::__libcpp_allocate(__s, __align),
        -:  939:                     __builtin_new_deleter(__s, __align));
        -:  940:  }
        -:  941:
        -:  942:  static void __deallocate_bytes(void* __p, size_t __s,
        -:  943:                                 size_t __align) _NOEXCEPT {
        -:  944:      _VSTD::__libcpp_deallocate(__p, __s, __align);
        -:  945:  }
        -:  946:
        -:  947:  template <class _Tp>
        -:  948:  _LIBCPP_NODEBUG _LIBCPP_ALWAYS_INLINE
        -:  949:  static __holder_t __allocate_type(size_t __n) {
        -:  950:      return __allocate_bytes(__n * sizeof(_Tp), _LIBCPP_ALIGNOF(_Tp));
        -:  951:  }
        -:  952:
        -:  953:  template <class _Tp>
        -:  954:  _LIBCPP_NODEBUG _LIBCPP_ALWAYS_INLINE
        -:  955:  static void __deallocate_type(void* __p, size_t __n) _NOEXCEPT {
        -:  956:      __deallocate_bytes(__p, __n * sizeof(_Tp), _LIBCPP_ALIGNOF(_Tp));
        -:  957:  }
        -:  958:};
        -:  959:
        -:  960:
        -:  961:_LIBCPP_END_NAMESPACE_STD
        -:  962:
        -:  963:_LIBCPP_POP_MACROS
        -:  964:
        -:  965:#if defined(_LIBCPP_HAS_PARALLEL_ALGORITHMS) && _LIBCPP_STD_VER >= 17
        -:  966:#   include <__pstl_memory>
        -:  967:#endif
        -:  968:
        -:  969:#endif // _LIBCPP_MEMORY
        -:  970:
        -:  971:// TODO(ldionne):
        -:  972:// Remove this unnecessary header. Without it, several clients don't build anymore because
        -:  973:// they do not properly include <cassert> before using the assert macro.
        -:  974:#include <cassert>
